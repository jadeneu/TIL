# 정규표현식
### 숫자 대표문자
* **\d**: 숫자를 대표하는 정규표현식이다. 이때 d는 digit을 뜻한다.

### 글자 대표문자
* **\w**: 글자를 대표하는 정규표현식이다. `\w`는 `a,b,c,가,나,다,1,2`와 같은 문자와 숫자를 포함한다. 특수문자는 포함하지 않지만, `_`(언더스코어)는 포함한다.

### 하나 이상(+)
`\d`는 숫자를 한글자만 찾는다. 그런데, 전화번호를 구성하는 043이나 2568같이 연결된 숫자를 찾고 싶을 때는 어떻게 해야 할까?

그럴 땐 `+`를 이용하면 된다. `+`는 "하나 혹은 그 이상 연결된"이라는 뜻이다. 따라서 `\d+`는 "하나 혹은 그 이상 연결된 숫자"를 의미한다.

### 0개 이상(\*)
정규표현식으로 010, 123, 456 중 자연수를 찾으려면 어떻게 해야 할까? <br>
자연수는
* 0으로 시작하지 않으니 자연수의 첫자리는 반드시 1 ~ 9 중에 하나이어야 한다.

다시 말해, 자연수는 다음과 같이 표현할 수 있다.
1. 처음에 1~9 중 하나의 숫자가 나온 다음
2. 그 뒤에는 숫자가 0개 이상 나온다.

`*`은 "0개 이상"이라는 뜻이다. 따라서 `\d*`는 "숫자가 0개 이상이다"를 의미한다. 이를 이용하면 자연수는 `[1-9]\d*`로 표현할 수 있다.

### 있거나 없거나?(?)
전화번호는 "-"을 포함하거나, 포함하지 않을 수 있다. 예를 들어, 다음은 모두 유효한 전화번호이다.
```
021234567
02-123-4567
```
따라서 전화번호는 연속되는 숫자 3 ~ 4개 사이에 `-`가 있거나 없다고 표현할 수 있다.

`?`는 '있거나 없거나'라는 뜻이다. 따라서 `-?`는 "-가 있거나 없다"를 의미한다. 따라서 이를 연속하는 숫자는 `\d+`와 조합하면 전화번호를 찾는 정규표현식을 만들 수 있다.
```
\d+-?\d+-?\d+
```
그러나 위 정규표현식은 "010 2454 3457"과 같이 공백이 포함된 전화번호를 찾을 수 없다는 한계가 있다.
```
021234567
02-123-4567
010 2454 3457
```
모든 전화번호를 찾으려면 "-가 있거나 없다"는 조건이 아니라 **"- 또는 공백이 있거나 없다"** 는 조건을 써야 한다.

`-` 또는 ` `(공백)이 있거나 없다는 조건은 `[- ]?`로 표현할 수 있다.
```
\d+[- ]?\d+[- ]?\d+
```

### n번({})
앞서 배운 `\d+[- ]?\d+[- ]?\d+` 정규표현식으로는 전화번호를 찾는데 한계가 있다. "0030589-5-95826"과 같이 연결된 숫자가 너무 많은 문자열도 전화번호라고 인식한다.

`{숫자}`는 "`숫자`번 반복한다"는 뜻이다. 예를 들어 `\d{2}`는 "숫자가 연속 두 번 나온다"는 뜻이다.
```python
\d{2}[- ]?\d{3}[- ]?\d{4}
# ex) 02-123-4567
```

### n~m번({})
앞서 배운 `\d{2}[- ]?\d{3}[- ]?\d{4}` 정규표현식으로는 전화번호의 첫 부분에 숫자가 3번(010 2454 3457) 나오는 경우를 인식하지 못한다는 한계가 있다. 
```
021234567
02-123-4567
010 2454 3457
```
`{숫자1, 숫자2}`는 "숫자1부터 숫자2까지 반복한다"는 뜻이다. 예를 들어, `\w{2,3}`는 "문자가 2 ~ 3번 나온다"는 뜻이다.

전화번호의 자릿수는 다음과 같다. 따라서 전화번호는 `\d{2,3}[- ]?\d{3,4}[- ]?\d{4}`와 같이 표현할 수 있다.

　|자리수
---|---
처음|2~3자리
가운데|3~4자리
마지막|4자리

### 몇 개 중에 고르기
알파벳 중에 소문자 모음(a,e,i,o,u)만 고르고 싶을 땐 어떻게 할까?

그럴 때는 `[aeiou]`라고 적어주면 된다. 정규표현식에서 대괄호[ ] 안에 글자를 넣으면 해당 글자를 모두 선택할 수 있다.

### 범위에서 고르기
소문자 알파벳만 고르고 싶을 땐 어떻게 할까?<br>
`[abcdefghijklmnopqrlstuvwxyz]`처럼 대괄호 안에 소문자를 모두 나열할 수도 있지만 더 간단한 방법이 있다.

간단히 `[a-z]`를 쓰자. `[a-z]`는 "a부터 z까지 글자를 모두 선택하라"는 의미이다.

그렇다면 **연속된 영어 소문자**를 찾으려면 어떻게 할까?
1. 소문자를 뜻하는 `[a-z]`와
2. 반복을 뜻하는 `+`를 붙여 => `[a-z]+`를 쓴다.

### 한글 고르기
한글 단어를 찾으려면 어떻게 할까?

한글의 첫 번째 글자는 `가`이고 마지막 글자는 `힣`이다. 따라서 한글은 `[가-힣]`으로 찾을 수 있다.<br>
`[가-힣]+`으로 찾으면 연속된 한글이 나온다.

### 기타 대표문자
* `^` - 반대(not)라는 의미를 갖는다. 예를 들어 `[^0-9]`라는 정규 표현식은 숫자가 아닌 문자만 매치된다.
* `\s` - 공백 문자(스페이스, 탭, 뉴라인)
* `\S` - 공백 문자를 제외한 문자
* `\D` - 숫자를 제외한 문자. `[^0-9]`와 동일한 표현식이다.
* `\W` - 글자 대표 문자를 제외한 글자들(특수문자, 공백 등). `[^a-zA-Z0-9_]`와 동일한 표현식이다.

### 정규식 그룹(Group)
정규 표현식에서 ( ) 괄호는 그룹을 의미한다. 예를 들어, 전화번호의 패턴을 `\d{3}-\d{3}-\d{4}` 와 같이 표현하였을 때, 지역번호 3자를 **그룹1**으로 하고 나머지 7자리를 **그룹2**로 분리하고 싶을 때, (\d{3})-(\d{3}-\d{4}) 와 같이 둥근 괄호로 묶어 두 그룹으로 분리할 수 있다.

* **matchObj.group()**
  ```python
  matchObj = re.search('match', "'matchObj' is a good name, but 'm' is convenient.")
  print(matchObj)

  print(matchObj.group())
  print(matchObj.groups())

  print('# ---------------------------------------------------------------- #')

  m = re.search('\d{4}-(\d?\d)-(\d?\d)', '1868-12-10')
  print(m)

  print(m.group())
  print(m.groups())
  ```
  결과
  ```
  <_sre.SRE_Match object; span=(1, 6), match='match'>
  match
  ()
  # ---------------------------------------------------------------- #
  <_sre.SRE_Match object; span=(0, 10), match='1868-12-10'>
  1868-12-10
  ('12', '10')
  ```
  matchObj의 **group** 메서드는 정규식 전체의 일치부를 찾는다. 반면에 **groups** 메서드는 명시적으로 캡처(`()`로 감싼 부분)한 부분을 반환한다.

  **group**과 **groups**의 사용법을 좀 더 보도록 하자.
  ```python
  m = re.search('\d{4}-(\d?\d)-(\d?\d)', '1868-12-10')
  print('m:', m)

  print('m.group():', m.group())

  for i in range(0, 3):
      print('m.group({}): {}'.format(i, m.group(i)))

  print('m.groups():', m.groups())
  ```
  결과
  ```python
  m: <_sre.SRE_Match object; span=(0, 10), match='1868-12-10'>
  m.group(): 1868-12-10
  m.group(0): 1868-12-10
  m.group(1): 12
  m.group(2): 10
  m.groups(): ('12', '10')
  ```
  결과를 보면
  * group(i)는 i번째 소괄호에 명시적으로 캡처된 부분만을 반환한다.
  * group(0)은 전체 일치부를 반환하며, group()과 효과가 같다.
  * groups()는 명시적으로 캡처된 모든 부분 문자열을 반환한다.

  i번째 캡처된 부분은, i번째 여는 괄호와 대응된다고 생각하면 된다. <br>
  주의할 점은 group(0)이 0번째 캡처를 의미하는 것이 아니라 전체 일치부를 반환한다는 것이다.

<br>

* **명명 그룹**<br>
  많은 프로그래밍 언어의 정규표현식은 명명 그룹 기능을 지원한다.<br>
  파이썬 기준으로는 `(?P<name>regex)` 형식으로 쓴다.

  예시를 하나 보자.
  ```python
  matchObj = re.match(
      r'(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d) (?P=year)\.(?P=month)\.(?P=day)',
      '2018-07-28 2018.07.28')

  print(matchObj.group())
  print(matchObj.groups())
  print(matchObj.group(1))
  ```
  결과
  ```
  2018-07-28 2018.07.28
  ('2018', '07', '28')
  2018
  ```
  명명 그룹의 재참조는 `(?P=name)` 형식으로 쓰면 된다.



<br><br>

## References
* [프로그래머스 정규표현식 강의]https://programmers.co.kr/learn/courses/11
* https://wikidocs.net/4308














