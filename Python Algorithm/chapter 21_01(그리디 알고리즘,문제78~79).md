# 목차

# 21장 그리디 알고리즘
> 585p

> 그리디 알고리즘(Greedy Algorithm)이란 바로 눈앞의 이익만을 좇는 알고리즘을 말한다.<br>
대부분의 경우에는 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우도 있다.

그리디 알고리즘은 최적화 문제를 대상으로 한다.<br>
최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.<br>
따라서 그리디(탐욕이라는 뜻)라는 단어는 이 알고리즘의 원리에 잘 어울리는 단어다. 물론 대부분의 문제들은 이런 로컬 최적해(Locally Optimum Solution)를 찾는 탐욕스런 방법으로는 문제를 해결할 수 없다. <br>
그러나 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용한 알고리즘이기도 하다.

그리디 알고리즘이 잘 작동하는 문제들은 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들이다. <br>
여기서 **탐욕 선택 속성이란** 앞의 선택이 이후 선택에 영향을 주지 않는 것을 말한다. <br>
다시 말해 그리디 알고리즘은 선택을 다시 고려하지 않는다.<br>
또한 **최적 부분 구조란** 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다.

이렇게 탐욕 선택 속성과 최적 부분 구조의 2가지 조건을 만족하면 최적해를 찾을 수 있다.<br>
하지만 그렇지 않더라도 그리디 알고리즘은 정답을 근사하게 찾는 용도로 활용할 수 있으며, 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

### 그리디 알고리즘 예
* 최단 경로 문제를 풀이하는 **다익스트라 알고리즘** → 최적해 보장
* 압축 알고리즘인 **허프만 코딩 알고리즘** (허프만 트리를 빌드할 때 쓰임) → 최적해 보장
* 의사결정 트리 알고리즘으로 유명한 **ID3 알고리즘** (머신러닝) → 최적해 보장 X

### 그리디 알고리즘과 다이나믹 프로그래밍의 차이
그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 흔히 다이나믹 프로그래밍과 비교되는데, 서로 풀 수 있는 문제의 성격이 다르며 알고리즘의 접근 방식 또한 다르다.<br>
**다이나믹 프로그래밍**이 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션(Globally Optimum Solution)에 대한 선택을 한다면,<br>
이에 반해 **그리디 알고리즘**은 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태로, 서로 반대 방향으로 접근하는 구조를 띤다.

<br>

그렇다면 여기서는 그리디 알고리즘을 중심으로 풀 수 있는 문제, 다이나믹 프로그래밍으로 풀어야 하는 문제, 그리디 알고리즘으로는 풀 수 없는 문제들에 대해 차례대로 살펴보자.

<br><br>

## 배낭 문제
배낭 문제(Knapsack Problem)는 조합 최적화(Combinatorial Optimization) 분야의 매우 유명한 문제로, <br>
쉽게 말해 그림 21-1과 같이 배낭에 담을 수 있는 무게의 최댓값(15kg)이 정해져 있고 각각 짐의 가치($)와 무게(kg)가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록,<br>
즉 **$(달러)의 가치가 최대가 되도록 짐을 고르는 방법을 찾는 문제**다.

배낭 문제는 그림 21-1과 같이 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(Fractional Knapsack Problem)(그리디 알고리즘으로 해결)와 23장의 그림 23-5와 같이 짐을 쪼갤 수 없는 경우인 0-1 배낭 문제(다이나믹 프로그래밍으로 해결)로 나뉜다.

우선, 그림 21-1처럼 짐을 쪼갤 수 있는 분할 가능 배낭 문제부터 먼저 풀어보자.

<img src="https://user-images.githubusercontent.com/55045377/131242388-b5e1c970-9bfe-4a99-a933-2f5e7da61bf0.png" width=50% height=50%>

* **tip**<br>
여기에서는 단위 무게당 얻는 이익이 큰 것부터 배낭에 넣는다. → 즉 "가치($)/무게(kg)"가 큰 것부터 넣는다.

이 그림에서는 C의 단가가 2.5달러(10/4)로 가장 높으므로, C, B, E, D 순으로 총 8kg의 짐을 배낭에 담고 마지막 남은 7kg을 위해 A의 7/12 만큼을 쪼개서 배낭에 그리디 알고리즘으로 담는다.<br>
이렇게 하면 17.3 이라는 최적해를 찾을 수 있다. 

이 부분을 코드로 구현해보면 다음과 같다.
```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

r = fractional_knapsack(cargo)
```
**(1) 먼저, 짐 cargo를 '(가격, 무게)'의 튜플 리스트로 정의하고, 함수 fractional_knapsack()을 호출한다.**

<br>

앞서 단가 기준으로 알고리즘을 설명한 그대로 구현하기 위해 **(2) 단가를 계산하고 역순으로 정렬한다.**<br>
즉 가장 단가가 높은 짐이 맨 위에 오도록 다음과 같이 구현한다.
```python
for c in cargo:
    pack.append((c[0] / c[1], c[0], c[1]))
pack.sort(reverse=True)
```

**(3) 이제 단가 순으로 그리디 알고리즘으로 계산하면 된다.** 전체 코드는 다음과 같다.
```python
def fractional_knapsack(cargo):
    capacity = 15
    pack = []
    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1]))
    pack.sort(reverse=True)
    
    # 단가 순 그리디 계산
    total_value: float = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2]
            total_value += p[1] * fraction
            break
            
    return total_value
```
이처럼 구현했을때 total_value는 17.3을 구할 수 있다. 앞서 알고리즘을 설명했을 때와 동일한 정답이다.

* **주의**<br>
그러나 이 문제에서 만약 짐을 쪼갤 수 없다면 지금까지 실행한 방식대로 단가 순으로 배치해선 안 된다.<br>
이와 같이 짐을 쪼갤 수 없는 0-1 배낭 문제는 23장 632페이지에서 풀이해본다.

<br><br>

## 동전 바꾸기 문제
또 다른 유명한 문제로 동전 바꾸기 문제(Coin-Change Problem)가 있다. 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다.<br>
우리나라 동전은 항상 배수 이상이므로 그리디로 풀 수 있다.

예를 들어 160원을 거슬러 준다면 10원짜리 16개보다는, 100원짜리 하나, 50원짜리 하나, 10원짜리 하나로, 각각의 동전을 최대한 활용하는 그리디한 방법이 **가장 작은 동전 개수로 거슬러줄 수 있는 방법**이다.

* **주의**<br>
그런데 만약 다른 나라에 갔더니 80원짜리 동전이 더 있다고 치자. 이 경우엔 더 이상 그리디하게 풀 수 없다.<br>
160원을 거슬러줘야 한다면 80원짜리 2개가 정답인데 그리디 알고리즘으로는 100원부터 선택하게 될 것이고 이렇게 하면 80원 2개로 풀이할 수 없기 때문이다.<br>
이 경우 앞서 0-1 배낭 문제와 마찬가지로 다이나믹 프로그래밍으로 풀어야 한다.

<br><br>

## 가장 큰 합
세 번째로는, 그리디 알고리즘의 실패 사례를 살펴보자. <br>
노드를 계속 더해가다가 마지막에 가장 큰 합이 되는 경로를 찾는 문제다. 일례로 그림 21-2를 살펴보자.

<img src="https://user-images.githubusercontent.com/55045377/131302140-a65e4146-6821-4b6f-a3eb-883520cdbdab.png" width=40% height=40%>

7부터 시작해 최종적으로 가장 큰 합을 만들기 위해서는 간선으로 연결된 2가지 선택지 중 더 큰 수를 계속 더해나가면 될 것 같다. <br>
그림 21-2는 전형적인 그리디 알고리즘의 형태로, 매번 가장 큰 값을 취해 나가면 7 -> 12 -> 6을 이어서 선택하게 된다.<br>
그런데 이 경우 합은 25에 불과하다. 만약 7에서 3을 택하고 99를 택하면 무려 109가 될 수 있다.<br>
그러나 그리디 알고리즘으로는 99를 발견할 수 없다. 7은 3과 12 중에서 절대로 3을 택하지 않을 것이기 때문이다.<br>
이 문제는 이진 트리를 정렬한다든지 등의 추가 작업을 하지 않는 한, 그리디 알고리즘으로는풀이할 수 없다.

이제 그리디 알고리즘으로 풀 수 있는 다른 문제를 살펴보자.

<br><br>

## 문제 78 주식을 사고팔기 가장 좋은 시점 II
> 590p

* 여러 번의 거래로 낼 수 있는 최대 이익을 산출하라.
* 입력
```
[7,1,5,3,6,4]
```
* 출력
```
7
```
* 설명<br>
1일 때 사서 5일 때 팔아 4의 이익을 얻고, 3일 때 사서 6일 때 팔아 3의 이익을 얻는다. 둘을 합하면 7이 된다.

<br><br>

### 문제 78 내가 구현한 코드
```python
def solution(lst):
  max_p = 0

  for i in range(len(lst)-1):
    if lst[i] < lst[i+1]:             # 1
      max_p += lst[i+1] - lst[i]
    else:                             # 2
      continue
  
  return max_p

lst = [7,1,5,3,6,4]
print(solution(lst))
```
* **# 1**: `lst`의 현재 인덱스와 다음 인덱스 값을 비교해서 다음 인덱스 값이 더 크다면 두 값의 차를 `max_p`에 더한다.
* **# 2**: 아니라면 continue를 해서 다음 인덱스로 넘어간다.

<br><br>

## 문제 78 주식을 사고팔기 가장 좋은 시점 II 풀이
### 풀이1. 그리디 알고리즘
7장 '배열'에서 풀어본 12번 '주식을 사고팔기 가장 좋은 시점' 문제의 2탄 격인 문제로, 한 번이 아닌 여러 번의 거래를 할 수 있다는 차이가 있다. <br>
12번 문제를 풀이할 때 사용한 그림 7-12를 다시 한번 그림 21-3으로 가져와본다.

<img src="https://user-images.githubusercontent.com/55045377/131307768-8af4be17-0780-4b5e-9ab8-83ab0fa6c630.png" width=40% height=40%>

이 문제는 단 한 번의 거래였기 때문에 저점과 고점에만 체크했다. <br>
그러나 이제는 여러 번 거래를 할 수 있다. 그렇다면 해법은 간단하다. 내리기 전에 팔고, 오르기 전에 사면 된다. <br>
따라서 항상 이익을 내는 방향으로 몇 번이든 사고팔고를 반복하면 된다. '탐욕'이라는 의미에 잘 어울리는 그리디 알고리즘 문제라 할 수 있다.

다시 한번 풀이에 맞게 그림을 그려보면 그림 21-4와 같다.

<img src="https://user-images.githubusercontent.com/55045377/131308357-1c44954c-8a4a-4571-85a4-d41684c2788e.png" width=40% height=40%>

지난번 문제 그림 21-3에서 고점, 저점 체크를 제거했고, 다음번 값이 오르면 사고 다음번 값이 내리면 파는, 항상 그리디하게 사고파는 형태로 그림 21-4와 같이 변경했다.

이와 같이 다음번 값이 현재보다 오르는 경우에 항상 이익을 취하는 형태로, 실제 코드를 구현하면 될 것 같다.<br>
계속 오르는 경우라도 몇 번이든 사고팔 수 있기 때문에, 매번 단계마다 이익을 취하는 탐욕 구조로 구현할 수 있다.
```python
from typing import List


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        # 값이 오르는 경우 매번 그리디 계산
        for i in range(len(prices) - 1):
            if prices[i + 1] > prices[i]:
                result += prices[i + 1] - prices[i]
        return result
```

<br><br>

### 풀이2. 파이썬다운 방식
파이썬다운 방식으로 바꿔보면 다음 정도로 전체 코드를 정리할 수 있다.
```python
from typing import List


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 0보다 크면 무조건 합산
        return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))
```
이전 풀이에서 단계별로 값이 올랐는지 가격을 매번 비교하는 방식으로 풀이했다.<br>
그런데 어차피 곰곰이 생각해보면, 매번 이익을 계산해 0보다 크면 무조건 합산할 수 있다.<br>
마찬가지로 탐욕 구조며, 동일한 결과를 얻을 수 있다. 실행 속도 또한 양쪽 모두 동일하다.

<br><br>

## 문제 79 키에 따른 대기열 재구성
> 593

* 여러 명의 사람들이 줄을 서 있다. 각각의 사람은 (h, k)의 두 정수 쌍을 갖는데, h는 그 사람의 키, k는 앞에 줄 서 있는 사람들 중 자신의 키 이상인 사람들의 수를 뜻한다. 이 값이 올바르도록 줄을 재정렬하는 알고리즘을 작성하라.
* 입력
```
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]
```
* 출력
```
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```
* 설명<br>
키가 5인 사람이 가장 먼저 섰고, 앞에는 아무도 없다. 7인 사람이 뒤따르고, 그보다 키가 더 큰 사람은 아무도 없다. 5인 사람이 섰으며, 앞에 5, 7 두 명이 자신보다 크거나 같다. 6인 사람의 앞에는 자신보다 큰 키 7인 사람 한 명이 있다. 4인 사람 앞에는 5, 7, 5, 6 네 명이 있다. 마지막으로 7인 사람 앞에 자신보다 크거나 같은 이는 키가 7인 사람 한 명이다.

<br><br>

### 문제 79 내가 구현한 코드
```python

```

<br><br>

## 문제 79 키에 따른 대기열 재구성 풀이
### 풀이1. 우선순위 큐 이용
먼저, 이 문제의 입출력인 대기열을 나타낸 그림 21-5는 각각 자신보다 앞의 위치에 있는 키가 크거나 같은 사람의 숫자를 표시했다.

이 그림을 잘 살펴보면 일정한 패턴이 엿보인다.<br>
이 문제는 우선순위 큐를 이용하면 쉽게 풀 수 있다. **우선순위 큐 자체가 매번 그때그때의 최소 또는 최댓값을 추출하기** 때문에, 그리디에 어울리는 대표적인 자료구조라 할 수 있다.<br>
실제로 그리디 문제의 대부분은 우선순위 큐를 활용해 풀이한다.

<img src="https://user-images.githubusercontent.com/55045377/131429643-5866f38c-6d42-4522-956b-5a35f998bac5.png" width=60% height=60%>

이 문제의 경우 우선순위 큐를 이용해 순서대로 예제 입력값을 추출해보면 다음과 같은 순서가 된다.
```
[[7,0]] (0번째 인덱스에 [7 ,0] 삽입 )
[[7 ,0], [7 ,1]] (1번째 인텍스에 [7 ,1] 삽입 )
[[7 ,0], [6 ,1], [7 ,1]] (1번째 인텍스에 [6 ,1] 삽입 )
[[5 ,0] ,[7 ,0] ,[6 ,1] ,[7 ,1]] (0번째 인텍스에 [5 ,0] 삽입)
[[5 ,0] ,[7 ,0] , [5 ,2] ,[6 ,1] ,[7 ,1]] (2번째 인텍스에 [5 ,2] 삽입)
[[5 ,0] , [7 ,0] , [5 ,2] ,[6 ,1] ,[4 ,4] ,[7 ,1]] (4번째 인텍스에 [4 ,4] 삽입 )
```



















