# 목차

# 17장. 정렬
## 문제 59 구간 병합
* 겹치는 구간을 병합하라.
* 입력
```
[[1,3],[2,6],[8,10],[15,18]]
```
* 출력
```
[[1,6],[8,10],[15,18]]
```
* 설명<br>
  [1,3]과 [2,6]이 겹치므로 [1,6]이 된다.
  
<br><br>

* **내가 짠 코드**
```python

```

<br><br>

## 문제 59 구간 병합 풀이
### 풀이1. 정렬하여 병합
이 문제를 풀기 위해서는 먼저 정렬을 수행한다. 정렬 순서는 첫 번째 값을 기준으로 한다.
```python
sorted(intervals, key=lambda x: x[0])
```
람다를 이용하면 첫 번째 값을 키로 이용하라는 지시를 할 수 있다. <br>
두 번째 값을 사용할 경우에는 당연히 x[1]로 지정하면 된다.<br>
그렇게 했을 때 현재 아이템의 시작이 이전 아이템의 끝과 겹치게 되면 그림 17-9와 같이 최댓값을 기준으로 병합하는 형태로 계속 반복해 나간다.

<img src="https://user-images.githubusercontent.com/55045377/126862200-ec2a3695-9b37-4f6a-83ce-0d5d4f00a9ae.png" width=70% height=70%>

이 그림에서 (1,3)은 (2, 6)과 병합되어 (1, 6)이 되었다.<br>
만약 다음 아이템의 시작 값이 이전 아이템의 끝과 더 이상 겹치지 않게 된다면, 병합을 멈추고 다음과 같이 merged += i, 를 이용해 새로운 아이템으로 추가한다.<br>
전체 코드는 다음과 같다.
```python
def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    merged = []
    for i in sorted(intervals, key=lambda x: x[0]):
        if merged and i[0] <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], i[1])
        else:
            merged += i,
    return merged
```
이 방식의 시간 복잡도는 정렬에 소요되는 O(n log n) 정도다.<br>
나머지 리스트를 순회하는 작업은 선형 시간에 수행되므로, 상한은 마찬가지로 O(n log n)이다.
<br><br>

### 문법. 콤마(,) 연산자
이 풀 01 에는 중간에 특이한 문법이 등장한다.


































