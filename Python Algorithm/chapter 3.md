# 목차
* [출처](#출처)


<img src="https://user-images.githubusercontent.com/55045377/114988963-e73fbe80-9ed1-11eb-8410-1b83e64182ac.jpg">

3장 리뷰 시작!

---

# 3장 파이썬
## 인덴트
* **정의**<br>
인덴트는 들여쓰기를 의미한다.<br><br>
파이썬의 대표적인 특징이기도 한 인덴트는 공식 가이드인 PEP 8에 따라 공백 4칸을 원칙으로 한다.
<br><br>

## 네이밍 컨벤션
* **정의**<br>
파이썬의 변수명 네이밍 컨벤션(Naming Convention)은 각 단어를 밑줄(_)로 구분하여 표기하는 스네이크 케이스(Snake Case)를 따른다.
<br><br>

## 타입 힌트
* **정의**<br>
타입을 지정할 수 있는 타입 힌트가 Python 3.5 부터 도입되었다.

* **설명**<br>
기존에 타입 힌트를 사용하지 않는 파이썬 함수는 다음과 같이 함수를 정의해 왔다.<br>
  ```python
  def  fn(a):
  ...
  ```
  + 장점 : 빠르게 정의해서 사용할 수 있다.<br><br>
  + 단점 : 파라미터 a에 숫자를 넘겨야 하는지, 문자를 넘겨야 하는지 알 수 없다. <br>
  그리고 이 함수의 리턴값이 무엇인지도 알 수 없다.
  
  <br><br>
  타입 힌트를 사용하게 되면 다음과 같다.
  ```python
  def  fn(a: int) -> bool:
  ...
  ```
  이제 fn() 함수의 파라미터 a가 정수형임을 분명하게 알 수 있으며<br>
  리턴값으로 True 또는 False 를 리턴할 것이라는 점도 확실하게 알 수 있다.
  <br><br><br>
  리스트 / 딕셔너리 / 튜플을 타입 힌트로 표현하는 방법은 아래와 같다.
  ```python
  num_list = List[int]
  test_dict = Dict[str, int]
  test_tuple = Tuple(int)
  ```
  <br><br>
  **----------꿀팁!----------**<br>
  온라인 코딩 테스트를 할 때 **mypy**를 사용하면 타입 힌트에 오류가 없는지 자동으로 확인할 수 있기 때문에 이를 통해 수정 후 코드를 제출할 수 있다.<br>
  mypy 는 pip 로 설치할 수 있다. (참고 80p)
<br><br>

## 리스트 컴프리헨션
* **정의**<br>
리스트 컴프리헨션(List Comprehension) 이란 기존 리스트를 기반으로 새로운 리스트를 만들어내는 구문이다.

* **설명**<br>
기존에 배운 문법으로 1부터 10까지 정수를 순서대로 가지고 있는 리스트를 생성하는 코드는 다음과 같다.
  ```python
  numbers = []
  for n in range (1, 10+1):
    numbers.append(n)
  ```
  이러한 코드를 컴프리헨션으로 표현하면 다음과 같다.
  ```python
  [x for x in range (10)]
  ```
  리스트 컴프리헨션이 작동하는 방식을 for 문과 비교해보면 다음과 같다.
  
  <img src="https://user-images.githubusercontent.com/55045377/114992039-42bf7b80-9ed5-11eb-917f-6cc45166d628.png" width=70% height=70%>
  
  리스트를 생성하는 방식은 대괄호([ ])를 통해 생성하는 방법은 동일하다.<br>
  차이점은 컴프리헨션은 리스트 내부에 코드를 작성한다는 점이다. <br>
  만약 딕셔너리 컴프리헨션 또는 셋 컴프리헨션 문법을 사용할때는 대괄호를 사용한다.

  <img src="https://user-images.githubusercontent.com/55045377/114992039-42bf7b80-9ed5-11eb-917f-6cc45166d628.png" width=70% height=70%>
  
  반복문은 별도로 작성하지않고 리스트 컴프리헨션은 리스트 내부에 작성하여 반복한다.
  
  <img src="https://user-images.githubusercontent.com/55045377/114992039-42bf7b80-9ed5-11eb-917f-6cc45166d628.png" width=70% height=70%>
  
  리스트 컴프리헨션은 for문에서 반복되는 변수를 콜론(:)다음에 줄을 바꿔 들여쓰기하는것이 아니라, for문앞에 작성한다. <br>
  컴프리헨션에서 사용한 x는 for문 내부에서append 메소드에 인자로 넣은 변수 n과 같다. 
  <br><br>
  
  만약 2의 배수를 10개 가지고 있는 리스트를 컴프리헨션을 사용해서 만들면 다음과 같다.
  ```python
  >>> [ 2 * x for x in range(1, 10+1) ]
  >>> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
  ```
  물론 리스트 컴프리헨션이라고 반드시 리스트만 가능한 것은 아니다.<br>
  버전 2.7 이후에는 다음과 같이 리스트 외에도 딕셔너리 등이 가능하도록 추가됐다.
  ```python
  a = {}
  for key, value in original.items():
    a[key] = value
  ```
  이와 같은 정의 코드는 다음과 같이 처리할 수 있다.
  ```python
  a = { key: value for key, value in original.items()}
  ```
<br><br>

## 제너레이터
* **정의**<br>
제너레이터는 루프의 반복(iteration) 동작을 제어할 수 있는 루틴 형태를 말한다.<br>
(iterator를 생성해주는 함수, 함수안에 yield 키워드를 사용함)

* **설명**<br>
yield 구문을 사용하면 제너레이터를 리턴할 수 있다.

기존의 함수는 return 구문을 맞닥뜨리면 값을 리턴하고 모든 함수의 동작을 종료한다.

그러나 yield는 제너레이터가 여기까지 실행 중이던 값을 내보낸다는 의미로, 중간값을 리턴한 다음 함수는 종료되지 않고 계속해서 맨 끝에 도달할 때까지 실행된다.
<br><br>

## range
* **설명**<br>
만약 생성할 숫자가 100만 개쯤 된다면 어떻게 될까? <br>
메모리에서 적지 않은 공간을 차지할 것이고 생성 시간도 오래 걸릴 것이다.<br>
그러나 제너레이터를 리턴하듯 range 클래스만 리턴하면 그렇지 않다. <br>
생성 조건만 정해두고 나중에 필요할 때 생성해서 꺼내 쓸 수 있다.<br><br>
다음은 숫자 100만 개를 생성하는 2가지 방법이다.
  ```python
  >>> a = [n for n in range(1000000)]
  >>> b = range(1000000)
  ```
  실제로 다음과 같이 len()으로 길이 비교를 해보면 둘 다 동일한 100만 개가 출력되며, 비교 연산자에서도 True를 리턴한다.
  ```python
  >>> len(a)
  1000000
  >>> len(b)
  1000000
  >>> len(a) == len(b)
  True
  ```
  그러나 a에는 이미 생성된 값이 담겨 있고, b는 생성해야 한다는 조건만 존재한다.

  이제 둘 사이의 메모리 점유율을 비교해보면 range 클래스를 리턴하는 방식의 장점이 쉽게 와닿을 것이다. (현재 b의 타입은 'range')
  ```python
  >>> sys.getsizeof(a)
  8697464
  >>> sys.getsizeof(b)
  48
  ```
  똑같이 숫자 100만 개를 갖고 있으나 range 클래스를 이용하는 b 변수의 메모리 점유율이 훨씬 적다.<br>
  100만 개가 아니라 1억 개라도 b 변수의 메모리 점유율은 동일하다. 생성 조건만 보관하고 있기 때문이다.
  <br><br>
  
  **------------중요-------------**<br>
  미리 생성하지 않은 값은 인덱스에 접근이 안 될 거라 생각할 수 있으나, 인덱스로 접근 시에는 바로 생성하도록 구현되어 있기 때문에 다음과 같이 리스트와 거의 동일한 느낌으로 불편 없이 사용할 수 있다.
  ```python
  >>> b[999]
  999
  ```

<br><br>

## enumerate
* **정의**<br>
enumerate()는 '열거하다'는 뜻의 함수로, 여러 가지 자료형(list, set, tuple 등)을 인덱스를 포함한 enumerate 객체로 리턴한다.

* **설명**<br>
사용 방법은 다음과 같다.
  ```python
  >>> a = [1,2,3,2,45,2,5}
  >>> a
  [1,2,3,2,45,2,5]
  >>> enumerate(a)
  <enumerate object at 0x1010f83f0>
  >>> list(enumerate(a))
  [(0,1),(1,2),(2,3),(3,2),(4,45),(5,2),(6,5)]
  ```
  이처럼 list()로 결과를 추출할 수 있는데, 인덱스를 자동으로 부여해주기 때문에 매우 편리하게 활용할 수 있다.

  그렇다면 **a = ['a1','b2','c3']** 가 있을 때 이 리스트의 인덱스와 값을 함께 출력하려면 어떻게 해야 할까?
  ```python
  for i,v in enumerate(a):
    print(i,v)
  ```
  인덱스와 값 모두 한 번에 깔끔하게 처리된다.
<br><br>

## // 나눗셈 연산자
(// 나눗셈 연산자는 알고 있는 내용이라 넘겼다)

### divmod()
몫과 나머지를 동시에 구하려면 divmod() 함수를 사용하면 된다.
```python
>>> divmod(5,3)
(1,2)
```

<br><br>

## print
* **설명**<br>
코딩 테스트 문제 풀이 과정에서 디버깅을 할 때 가장 자주 쓰는 명령은 바로 print()다.<br>
그렇다면 이를 좀 더 유용하게 활용할 수 있는 방법을 몇 가지 살펴보자.<br><br>
  **(1) 가장 쉽게 값을 출력하는 방법은 콤마(,)로 구분하는 것이다.**<br>
  이 경우 한 칸 공백이 디폴트로 설정되어 있으며, 그대로 출력하면 띄어쓰기로 값을 구분해준다.
  ```python
  >>> print('A1','B2')
  A1 B2
  ```
  <br>
  
  **(2) 다음과 같이 sep 파라미터로 구분자를 콤마(,)로 지정해줄 수도 있다.**<br>
  ```python
  >>> print('A1','B2', sep=',')
  A1,B2
  ```
  <br>
  
  print() 함수는 항상 줄바꿈을 하기 때문에 긴 루프의 값을 반복적으로 출력하면 디버깅 하기가 어려운데 이 경우<br>
  **(3) 다음과 같이 end 파라미터를 공백으로 처리하여 줄바꿈을 하지 않도록 제한할 수 있다.**<br>
  ```python
  print('aa', end=' ')
  print('bb')
  ---------------------
  aa bb
  ```
  <br>
  
  **(4) 리스트를 출력할 때는 join()으로 묶어서 처리한다.**<br>
  ```python
  >>> a = ['A', 'B']
  >>> print(' '.join(a))
  A B
  ```
  




## 출처
#### 1. 리스트 컴프리헨션
* https://wikidocs.net/22805

























