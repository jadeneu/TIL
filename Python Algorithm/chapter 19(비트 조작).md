# 목차

# 19장 비트 조작
원래 비트를 조작하는 것은 하드웨어와 관련이 깊다.<br>
1937년 클로드 섀넌(Claude Shannon)은 전기회로 스위치의 on/off를 이용한 스위칭 회로를 연구하면서 true, false의 2개 값으로 논리 연산을 설명하는 부울대수(Boolean Algebra)를 회로에 적용했고, 논리 게이트(Logic Gate)를 만들어냈다.<br>
이를 이용한 논리 회로(Logic Circuit)는 현대의 모든 디지털 컴퓨터의 기본 개념이자 근간을 이루고 있다.<br>
뿐만 아니라 현대에 이르러 비트 조작 기법은 하드웨어 뿐만 아니라 다양한 부분에 널리 활용된다.<br>
19장에서 살펴볼 비트 조작 또한 프로그래밍에서 활용하는 방법을 중심으로 다룬다. <br>
아울러 여기서는 수학적 표기보다는 컴퓨터과학에서 쓰이는 표기와 코드를 기준으로 살펴본다.

<br><br>

## 부울 연산자

<img src="https://user-images.githubusercontent.com/55045377/129554537-d14bb16c-4948-4b2f-904d-a7b493b11cf3.png" width=60% height=60%>

먼저, 가장 기본적인 부울 연산(Boolean Operation)부터 살펴보자.<br>
부울 연산은 그림 19-1과 같으며 코드로는 다음과 같이 표현할 수 있다.
```python
>>> True and False
False
>>> True or False
True
>>> not True
False
```
AND, OR, NOT은 기본 부울 연산자로, 연산들을 서로 결합하거나 조합해 다른 보조 연산을 만들어 낼 수 있다.<br>
대표적으로 XOR이 보조 연산에 해당하며, **기본 연산들의 조합으로 다음과 같이 XOR을 구성할 수 있다.**
```python
>>> x = y = True
>>> (x and not y) or (not x and y)
False
```
그러나 XOR은 단순한 보조 연산을 뛰어 넘어 디지털 논리 게이트에서 매우 중요한 위치를 차지한다.<br>
이후에 풀어볼 72번 문제에서 전가산기(Full Adder)를 구현해 보면서 XOR의 중요성을 다시 한번 실감하게 될 것이다.

<br><br>

## 비트 연산자
이번에는 비트 연산자(Bitwise Operator)를 살펴보자.
```python
>>> True & False
False
>>> True | False
True
>>> True ^ True
False
>>> ~ True
-2
```
부울 연산자와 마찬가지로 비트 연산자도 동일하게 잘 동작한다.<br>
그런데 비트 연산자 NOT(Bitwise NOT)인 **~(틸드)는 부울 변수에 적용하면 True는 1로 간주되어 -2가 된다.**<br>
비트 연산자 NOT은 2의 보수에서 1을 뺀 값과 같기 때문이다.<br>
따라서 십진수로 표현할 때는 NOT x = -x - 1이 된다. <br>
즉 NOT 1 = ~1 -1이 되어 -2가 된다.<br>
* 547페이지 '2의 보수' 참고.

## 2의 보수
### 보수
**보수**란, '두 수의 합이 진법의 밑수(N)가 되게 하는 수'를 말한다.

예를 들어 10진수 4의 10의 보수는 6이고, 10진수 2의 10의 보수는 8이다.

보수는 컴퓨터에서 음의 정수를 표현하기 위해서 고안되었다. 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기(Adder)만 이용하기 때문에 뺄셈은 덧셈으로 형식을 변환하여 계산해야 한다.<br>
즉 컴퓨터 내부에서는 A - B를 계산할 때 B의 보수(-B)를 구한 다음 A + (-B)로 계산하는 것이다.



<br><br>

## 비트 조작 퀴즈
이제 산술 연산(Arithmetic Operation)을 비롯한 몇 가지 비트 연산을 다음과 같이 살펴보자.
```python
>>> bin(0b0110 + 0b0010)   # 1
'0b1000'
>>> bin(0b0011 * 0b0101)   # 2
'0b1111'
>>> bin(0b1101 >> 2)       # 3
'0b11'
>>> bin(0b1101 << 2)       # 4
'0b110100'
>>> bin(0b0101 ^ ~0b1100)  # 5
'-0b1010'
```
덧셈인 '# 1' bin(0b0110 + 0b0010)은 쉽다. 자릿수가 초과할 때 다음 자리로 넘겨주는 십진수의 덧셈과 동일하게 처리하면 된다.<br>
'# 2' bin(0b0011 * 0b0101)도 마찬가지다. 이진수의 곱셈은 십진수의 곱셈과 동일하다.<br>
다만, 0은 모두 0이 되고, 1은 기존의 값이 그대로 내려온다. <br>
'# 2'의 0011과 0101 두 이진수의 곱셈 계산 과정은 다음 그림 19-2에서 볼 수 있다.

<img src="https://user-images.githubusercontent.com/55045377/129557665-a193065a-9d79-406f-887a-78333a59d579.png" width=35% height=35%>
























---
# References
* https://ndb796.tistory.com/4

<br><br><br>



