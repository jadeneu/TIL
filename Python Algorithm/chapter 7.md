# 7장 배열
> 배열은 값 또는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.

<br>자료구조는 크게 메모리 공간 기반의 **연속 방식**과 **포인터 기반**의 연결 방식으로 나뉜다.<br>
배열은 이 중에서 연속 방식의 가장 기본이 되는 자료형이다.<br>
(연결 방식의 가장 기본이 되는 자료형은 연결 리스트)

### 동적 배열의 등장
배열은 고정된 크기만큼의 연속된 메모리 할당이다.<br>
그러나 실제 데이터에서는 전체 크기를 가늠하기 힘들 때가 많다.<br>
그렇다면 미리 크기를 지정하지 않고 자동으로 조정할 수 있다면 좋지 않을까?<br>
이러한 고민을 해결하고자 크기를 지정하지 않고 자동으로 리사이징하는 배열인 **동적 배열**이 등장했다.

파이썬에서는 리스트가 동적 배열 자료형이다.<br>

### 동적 배열의 원리
동적 배열의 원리는 간단하다.<br>
미리 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사하는 식이다.<br>
대개는 **더블링(Doubling)** 이라 하여 2배씩 늘려주게 되는데, 당연히 모든 언어가 항상 그런 것은 아니다.

그렇다면 파이썬의 더블링 구조를 잠깐 살펴보자.<br>
CPython의 내부 구현을 살펴보면 동적 배열인 리스트의 구현은 CPython의 listobject.c에 정의되어 있다.<br>
여기에는 다음 코드에서 주석에 기술된 수치만큼인 0, 4, 8, 16, ... 순으로 재할당하도록 정의되어 있다.
```python
// cpython/Objects/listobject.c
// The growth pattern is: 0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
new_allocated = (size_t)newsize + (newsize >> 3) + (newsize < 9 ? 3 : 6);
```
이 재할당 비율을 그로스 팩터(Growth Factor), 즉 '성장 인자'라고 한다.<br>
파이썬의 그로스 팩터는 초반에는 2배씩 늘려 가지만, 전체적으로는 약 1.125배로, 다른 언어에 비해서는 다소 조금만 늘려가는 형태로 구현되어 있다.


### 정리
동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하게 활용할 수 있으며, 조회 또한 기존의 배열과 동일하게 O(1)에 가능하다.<br>
그러나 더블링이 필요할 만큼 공간이 차게 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업이 필요하므로 O(n) 비용이 발생한다.<br>
즉 최악의 경우 삽입 시 O(n)이 되지만 자주 일어나는 일은 아니므로, 분할 상환 분석에 따른 입력 시간은 여전히 O(1)이다.<br>
이처럼 동적 배열은 분할 상환 분석에 따른 시간 복잡도를 설명하는 대표적인 자료형이기도 하다.<br>
<br>
## 리트코드 문제
### 07. 두 수의 합
> 173p

* **내가 짠 코드**
```python
def two_sum(nums:list,target:int) -> list:
  new_list = []
  sum = 0

  for i in range(len(nums)):
    for j in range(i+1,len(nums)):
      sum = nums[i] + nums[j]
      if sum == target:
        new_list.append(i)
        new_list.append(j)
        return new_list



nums = list(map(int, input().split()))
target = int(input())

print(two_sum(nums,target))
```
<br>

* **꿀팁**<br>
한 번에 리스트로 입력 받고 싶다면 다음과 같은 형식을 사용하면 된다.
```python
l = list(map(int, input().split()))
```










