# 목차
* [chapter 6. 문자열 조작](#6장-문자열-조작)



<img src="https://user-images.githubusercontent.com/55045377/116873723-1a64aa80-ac53-11eb-8d03-5df57948b42d.jpg">
6장 리뷰 시작~

---

# 6장 문자열 조작
> 문자열 조작(String Manipulation)이란 문자열을 변경하거나 분리하는 등의 여러 과정을 말한다.

<br><br>

## 문제 01 유효한 팰린드롬
> 138p

### 문제 01 내가 구현한 코드

```python
def is_palindrome():
  word = input()

  #s는 시작, f는 마지막 인덱스
  s = 0
  f = len(word)-1
  flag = 1

  strs = word.lower() #word 문자 모두 소문자로 바꾸기

  nums = []
  alps = []
  #숫자를 아스키코드(숫자)로 변환
  for i in range(48,58):
    nums.append(chr(i))

  #숫자를 아스키코드(영어소문자)로 변환
  for i in range(97,123):
    alps.append(chr(i))


  while s != f and s < f:
    if strs[s] in nums or strs[s] in alps:
      if strs[f] in nums or strs[f] in alps:
        if strs[s] == strs[f]:
          s += 1
          f -= 1
          flag = 1
        else:
          flag = 0
          break
      else:
        f -= 1
    else:
      s += 1

  if flag:
    return 'true'
  else:
    return 'false'


print(is_palindrome())
```

* **참고 | '팰린드롬'이란**<br>
  앞뒤가 똑같은 단어나 문자으로, 뒤집어도 같은 말이 되는 단어 또는 문장을 팰린드롬(Palindrome)이라고 한다.<br>
  ex) '소주 만 병만 주소'
<br><br>

## 문제 01 유효한 팰린드롬 풀이
### 풀이1. 리스트로 변환
여기서는 직접 문자열을 입력받아 팰린드롬 여부를 판별해본다.<br>
이 문제는 대소문자 여부를 구분하지 않으며 영문자, 숫자만을 대상으로 한다는 제약 조건이 있다.<br>
따라서 이 부분에 대한 전처리부터 다음과 같이 구현한다.
```python
strs = []
for char in s:
    if char.isalnum():
        strs.append(char.lower())
```
여기서 isalnum()는 영문자, 숫자 여부를 판별하는 함수로, 이를 이용해 해당하는 문자만 추가한다.<br>
대소문자를 구분하지 않으므로 lower()로 모두 소문자로 변환한다.<br>
이렇게 하면 입력값이 A man, a plan, a canal: Panama 일 때 strs 리스트는 다음과 같은 값들이 담기게 된다.
```
['a', 'm', 'a', 'n', 'a', 'p', 'l', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'l', 'p', 'a', 'n', 'a', 'm', 'a']
```
<br>

이제 다음과 같이 팰린드롬 여부를 판별해보자.
```python
while len(strs) > 1:
    if strs.pop(0) != strs.pop():
        return False
```
파이썬의 리스트는 pop() 함수에서 인덱스를 지정할 수 있기 때문에, 이처럼 0을 지정하면 맨 앞의 값을 가져올 수 있다.<br>
이렇게 맨 뒷부분의 pop() 결과와 매칭해 나가면서 일치하지 않는 경우 False를 리턴한다. 모두 통과했다면 True를 리턴한다.

전체 코드는 다음과 같다.
```python
def isPalindrome(self, s: str) -> bool:
    strs = []
    for char in s:
        if char.isalnum():
            strs.append(char.lower())
            
    # 팰린드롬 여부 판별
    while len(strs) > 1:
        if strs.pop(0) != strs.pop():
            return False
            
    return True
```
<br><br>

### 풀이2. 데크 자료형을 이용한 최적화
이처럼 리스트만으로도 충분히 문제를 해결할 수 있지만, 데크(Deque)를 명시적으로 선언하면 좀 더 속도를 높일 수 있다.<br>
앞서 풀이1의 경우, 실행에 **304밀리초**가 걸렸다. 좋은 성능이라고 보기는 어려운데, 다음과 같이 간단히 데크로 변경하는 것만으로 얼마나 개선됐는지 살펴보자.
```python
def isPalindrome(self, s: str) -> bool:
    # 자료형 데크로 선언
    strs: Deque = collections.deque()
    
    for char in s:
        if char.isalnum():
            strs.append(char.lower())
            
    while len(strs) > 1:
        if strs.popleft() != strs.pop():
            return False
            
    return True
```
여기서 strs: Deque = collections.deque()와 같이 자료형을 데크로 선언하는 것만으로 64밀리초에 실행됐다. 앞서 풀이1의 리스트 풀이 대비 거의 5배 가까이 더 속도를 높일 수 있었다.<br>
이는 리스트의 pop(0)이 O(n)인 데 반해, 데크의 popleft()는 O(1)이기 때문이며, 각각 n번씩 반복하면, 리스트 구현은 O(n^2), 데크 구현은 O(n)으로 성능 차이가 크다.<br>
어쨌든 이 정도 성능이면 나쁘지 않다. 하지만 파이썬의 최적화된 내부 기능을 잘 활용해 성능을 좀 더 높여보자.
<br><br>

### 풀이3. 슬라이싱 사용
다음은 슬라이싱을 이용한 문제 풀이 코드다.
```python
def isPalindrome(self, s: str) -> bool:
    s = s.lower()
    # 정규식으로 불필요한 문자 필터링
    s = re.sub('[^a-z0-9]', '', s)
    
    return s == s[::-1] # 슬라이싱
```
여기서는 별달리 알고리즘이라 부를 만한 게 없다.<br>
정규식으로 불필요한 문자를 필터링하고, 문자열을 조작할 수 있는 파이썬의 슬라이싱(Slicing)을 사용했다.<br>
앞서 풀이에서는 isalnum()으로 모든 문자를 일일이 점검했다.

여기서는 문자열 전체를 한 번에 영숫자(Alphanumeric)만 걸러내도록 정규식으로 처리했다.<br>
또한 파이썬은 문자열을 배열이나 리스트처럼 자유롭게 슬라이싱할 수 있는 좋은 기능을 제공하며, [::-1]을 이용하면 뒤집을 수 있다.<br>
코드가 훨씬 더 줄어듦은 물론, 내부적으로 C로 빠르게 구현되어 있어 훨씬 더 좋은 속도를 기대할 수 있다.<br>
이 경우 실행 속도는 36밀리초로, 앞선 풀이2에 비해 약 2배 정도 더 속도를 높일 수 있었다.
<br><br>

### 풀이4. C 구현
> 142p 참고

<br><br>

#### 문법. 문자열 슬라이싱
파이썬에서는 문자열 슬라이싱이라는 매우 편리한 기능을 제공한다. 무엇보다 내부적으로 매우 빠르게 동작한다.<br>
위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내는데, 이 과정은 매우 빠르게 진행되므로 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 속도 개선에 유리하다.<br>
문자열을 별도로 리스트로 매핑하는 등의 처리는 데이터 구조를 다루는 입장에서는 좋은 방법이지만, 별도 자료형으로 매핑하는 과정에서 상당한 연산 비용이 필요하므로 전체적인 속도에서는 오히려 손해를 볼 수 있다.<br>
대부분의 문자열 작업은 슬라이싱으로 처리하는 편이 가장 빠르다.

표 6-1(143p)은 슬라이싱과 다른 연산 작업의 속도를 비교한 결과로서, 슬라이싱의 빠른 속도를 잘 보여준다.

> 표 6-1

<br>

이제 '안녕하세요'라는 문자열을 통해 슬라이싱의 활용 방법을 하나씩 살펴보자.
* **S[1:4] == 녕하세**<br>
  인덱스 1에서(0부터 시작) 4 이전까지는(4는 포함하지 않는다) 표현한다. 4개를 의미하는 게 아니므로 유의해야 한다.
* **S[1:-2] == 녕하**<br>
  인덱스 1에서 -2 이전까지(-2는 포함하지 않는다) 표현한다. 그림 6-1(144p)에서와 같이 뒤에서 부터는 음수로 접근이 가능하다.
* **S[1:] == 녕하세요**<br>
  문자열의 시작 또는 끝은 생략 가능하다.
* **S[:] == 안녕하세요**<br>
  둘 다 생략하면 사본을 리턴한다. 파이썬은 a = b와 같은 형태로 할당하면 변수의 값이 할당되는 것이 아니라 a 변수가 b 변수를 참조하는 형태가 된다.<br>
  참조가 아닌 값을 복사하기 위해 [:]를 사용할 수 있으며, 이 방식은 문자열이나 리스트를 복사하는 파이썬다운 방식(Phythonic Way)이기도 하다.
* **S[1:100] == 녕하세요**<br>
  인덱스가 지나치게 클 경우 문자열의 최대 길이만큼만 표현된다. S[1:]과 동일하다.
* **S[-1] == 요**<br>
  마지막 문자(뒤에서 첫 번째)
* **S[-4] == 녕**<br>
  뒤에서 4번째
* **S[:-3] == 안녕**<br>
  뒤에서 3개 글자 앞까지
* **S[-3:] == 하세요**<br>
  뒤에서 3번째 문자에서 마지막까지
* **S[::1] == 안녕하세요**<br>
  1은 기본값으로 동일하다.
* **S[::-1] == 요세하녕안**<br>
  뒤집는다
* **S[::2] == 안하요**<br>
  2칸씩 앞으로 이동한다.
  
<br><br>

## 문제 02 문자열 뒤집기
### 문제 02 내가 구현한 코드

```python
def reverse_list(s) -> list:
  s.reverse()
 
  return s

s = input()
new_list = list(s)
print(reverse_list(new_list))
```
<br><br>

## 문제 2 문자열 뒤집기 풀이
### 풀이1. 투 포인터를 이용한 스왑
























