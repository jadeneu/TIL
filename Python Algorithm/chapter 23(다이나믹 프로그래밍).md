# 목차

# 23장 다이나믹 프로그래밍
> 다이나믹 프로그래밍 알고리즘은 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가 나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘이다

다이나믹 프로그래밍 알고리즘을 이용하면, 문제의 **최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성**되는 경우의 문제, 즉 최적 부분 구조(Optimal Substructure)를 갖고 있는 문제를 풀이할 수 있다.

* 최적 부분 구조를 푸는 또 다른 알고리즘으로는 **그리디 알고리즘**이 있다.<br>
* 비슷한 유형의 문제를 풀이한다는 점에서 서로 비교 대상이 되기도 하는데, <br>
**그리디 알고리즘**은 항상 그 순간에 최적이라고 생각되는 것을 선택하면서 풀이해 나가는 것이고,<br>
**다이나믹 프로그래밍**은 중복된 하위 문제들(Overlapping Subproblem)의 결과를 저장해뒀다가 풀이해 나간다는 차이가 있다.<br>
* 여기서 중요한 점은 '중복된' 문제들이란 점이며, 중복되지 않는 문제들은 다이나믹 프로그래밍으로 풀지 않는다.<br>
* 대표적으로 병합 정렬과 퀵 정렬 등이 있으며, 이들은 모두 분할 정복 알고리즘으로 분류한다.

대부분의 재귀 알고리즘은 표 23-1에서 살펴볼 수 있는 것처럼 최적 부분 구조 문제를 풀 수 있다.<br>
이 중에서도 병합 정렬, 퀵 정렬과 같은 분할 정복 알고리즘은 '중복된 하위 문제들'을 푸는 것이 아니기 때문에 다이나믹 프로그래밍으로 분류하지 않는다.<br>
배낭 문제 중 분할 가능 배낭 문제(Fractional Knapsack Problem)는 '탐욕 선택 속성'이 있기 때문에 그리디 알고리즘으로 풀이할 수 있다(21장 참고).

<br>

* **표 23-1** 알고리즘과 풀이 가능한 문제들의 특징

<img src="https://user-images.githubusercontent.com/55045377/134760237-2bbc048d-22dd-4551-8da3-85a295f5f8d7.png" width=70% height=70%>

* 13장에서 살펴 본 다익스트라 알고리즘은 다이나믹 프로그래밍과 그리디 알고리즘 둘 다 해당하는 경우인데, <br>
BFS(너비 우선 탐색) 시 항상 최단 경로를 찾고 탐욕 선택 속성을 갖는 **그리디 알고리즘**이면서, <br>
이미 계산한 경로는 저장해두었다가 활용하며 중복된 하위 문제들을 푸는 **다이나믹 알고리즘**이기도 하다.<br>
* 즉 다익스트라 알고리즘은 '최적 부분 구조', '중복된 하위 문제들', '탐욕 선택 속성'을 모두 갖는 알고리즘이다.

<br><br>

## 최적 부분 구조




















