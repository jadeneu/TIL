# 목차

# 21장 그리디 알고리즘
> 585p

> 그리디 알고리즘(Greedy Algorithm)이란 바로 눈앞의 이익만을 좇는 알고리즘을 말한다.<br>
대부분의 경우에는 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우도 있다.

그리디 알고리즘은 최적화 문제를 대상으로 한다.<br>
최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.<br>
따라서 그리디(탐욕이라는 뜻)라는 단어는 이 알고리즘의 원리에 잘 어울리는 단어다. 물론 대부분의 문제들은 이런 로컬 최적해(Locally Optimum Solution)를 찾는 탐욕스런 방법으로는 문제를 해결할 수 없다. <br>
그러나 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용한 알고리즘이기도 하다.

그리디 알고리즘이 잘 작동하는 문제들은 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들이다. <br>
여기서 **탐욕 선택 속성이란** 앞의 선택이 이후 선택에 영향을 주지 않는 것을 말한다. <br>
다시 말해 그리디 알고리즘은 선택을 다시 고려하지 않는다.<br>
또한 **최적 부분 구조란** 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다.

이렇게 탐욕 선택 속성과 최적 부분 구조의 2가지 조건을 만족하면 최적해를 찾을 수 있다.<br>
하지만 그렇지 않더라도 그리디 알고리즘은 정답을 근사하게 찾는 용도로 활용할 수 있으며, 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

### 그리디 알고리즘 예
* 최단 경로 문제를 풀이하는 **다익스트라 알고리즘** → 최적해 보장
* 압축 알고리즘인 **허프만 코딩 알고리즘** (허프만 트리를 빌드할 때 쓰임) → 최적해 보장
* 의사결정 트리 알고리즘으로 유명한 **ID3 알고리즘** (머신러닝) → 최적해 보장 X

### 그리디 알고리즘과 다이나믹 프로그래밍의 차이
그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 흔히 다이나믹 프로그래밍과 비교되는데, 서로 풀 수 있는 문제의 성격이 다르며 알고리즘의 접근 방식 또한 다르다.<br>
**다이나믹 프로그래밍**이 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션(Globally Optimum Solution)에 대한 선택을 한다면,<br>
이에 반해 **그리디 알고리즘**은 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태로, 서로 반대 방향으로 접근하는 구조를 띤다.

<br>

그렇다면 여기서는 그리디 알고리즘을 중심으로 풀 수 있는 문제, 다이나믹 프로그래밍으로 풀어야 하는 문제, 그리디 알고리즘으로는 풀 수 없는 문제들에 대해 차례대로 살펴보자.

<br><br>

## 배낭 문제
배낭 문제(Knapsack Problem)는 조합 최적화(Combinatorial Optimization) 분야의 매우 유명한 문제로, <br>
쉽게 말해 그림 21-1과 같이 배낭에 담을 수 있는 무게의 최댓값(15kg)이 정해져 있고 각각 짐의 가치($)와 무게(kg)가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록,<br>
즉 **$(달러)의 가치가 최대가 되도록 짐을 고르는 방법을 찾는 문제**다.

배낭 문제는 그림 21-1과 같이 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(Fractional Knapsack Problem)(그리디 알고리즘으로 해결)와 23장의 그림 23-5와 같이 짐을 쪼갤 수 없는 경우인 0-1 배낭 문제(다이나믹 프로그래밍으로 해결)로 나뉜다.

우선, 그림 21-1처럼 짐을 쪼갤 수 있는 분할 가능 배낭 문제부터 먼저 풀어보자.

<img src="https://user-images.githubusercontent.com/55045377/131242388-b5e1c970-9bfe-4a99-a933-2f5e7da61bf0.png" width=50% height=50%>

* **tip**<br>
여기에서는 단위 무게당 얻는 이익이 큰 것부터 배낭에 넣는다. → 즉 "가치($)/무게(kg)"가 큰 것부터 넣는다.

이 그림에서는 C의 단가가 2.5달러(10/4)로 가장 높으므로, C, B, E, D 순으로 총 8kg의 짐을 배낭에 담고 마지막 남은 7kg을 위해 A의 7/12 만큼을 쪼개서 배낭에 그리디 알고리즘으로 담는다.<br>
이렇게 하면 17.3 이라는 최적해를 찾을 수 있다. 

이 부분을 코드로 구현해보면 다음과 같다.
```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

r = fractional_knapsack(cargo)
```
































