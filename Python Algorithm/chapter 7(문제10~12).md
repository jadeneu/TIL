# 목차
* [7장 배열](#7장-배열)
* [리트코드 문제](#리트코드-문제)
  + [문제 10 배열 파티션 I](#문제-10-배열-파티션-i)
  + [문제 10 배열 파티션 I 풀이](#문제-10-배열-파티션-i-풀이)
    - [풀이1. 오름차순 풀이](#풀이1-오름차순-풀이)
    - [풀이2. 짝수 번째 값 계산](#풀이2-짝수-번째-값-계산)
    - [풀이3. 파이썬다운 방식](#풀이3-파이썬다운-방식)
    - [정리](#정리)
  + [문제 11 자신을 제외한 배열의 곱](#문제-11-자신을-제외한-배열의-곱)
  + [문제 11 자신을 제외한 배열의 곱 풀이](#문제-11-자신을-제외한-배열의-곱-풀이)
    - [풀이1. 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈](#풀이1-왼쪽-곱셈-결과에-오른쪽-값을-차례대로-곱셈)
  + [문제 12 주식을 사고팔기 가장 좋은 시점](#문제-12-주식을-사고팔기-가장-좋은-시점)
  + [문제 12 주식을 사고팔기 가장 좋은 시점 풀이](#문제-12-주식을-사고팔기-가장-좋은-시점-풀이)
    - [풀이1. 브루트 포스로 계산](#풀이1-브루트-포스로-계산)
    - [풀이2. 저점과 현재 값과의 차이 계산](#풀이2-저점과-현재-값과의-차이-계산)
    - [참고. 최댓값과 최솟값](#참고-최댓값과-최솟값)
  





# 7장 배열
## 리트코드 문제
### 문제 10 배열 파티션 I
> 190p


* **내가 짠 코드**<br>
```python
def array_partition(nums:list) -> int:
  nums.sort()
  cnt = 0 # min(a,b)의 합

  for i in range(1,len(nums)+1,2):
    if i+1 <= len(nums):
      cnt += min(nums[-i],nums[-(i+1)])

  return cnt


nums = list(map(int,input().split()))
print(array_partition(nums))
```
<br><br>

### 문제 10 배열 파티션 I 풀이
#### 풀이1. 오름차순 풀이
문제가 상당히 특이하고 바로 이해하기가 쉽지 않다.<br>
그러나 찬찬히 살펴보면 페어의 min()을 합산했을 때 최대를 만드는 것은 결국 min()이 되도록 커야 한다는 뜻이고, 뒤에서부터 내림차순으로 집어넣으면 항상 최대 min() 페어를 유지할 수 있다.<br>
이 문제에서 배열 입력값은 항상 2n개일 것이므로 앞에서부터 오름차순으로 집어넣어도 결과는 같을 것이다.

뒤에서부터 내림차순으로 만들어도 결과는 동일하며, 여기서는 오름차순으로 구현해본다.<br>
전체 코드는 다음과 같다.
```python
def arrayPairSum(self, nums: List[int]) -> int:
  sum = 0
  pair = []
  nums.sort()
  
  for n in nums:
  # 앞에서부터 오름차순으로 페어를 만들어서 합 계산
  pair.append(n)
  if len(pair) == 2:
    sum += min(pair)
    pair = []
    
  return sum
```
<br><br>

#### 풀이2. 짝수 번째 값 계산
이렇게 페어에 대해 일일이 min() 값을 구하지 않아도 짝수 번째 값(0부터 시작하므로)을 더하면 될 것 같다. 정렬된 상태에서는 짝수 번째에 항상 작은 값이 위치하기 때문이다.<br>
불필요한 리스트 변수를 생략할 수 있기 때문에, 전체 코드 또한 많이 줄어들어 매우 간결하게 구현할 수 있다.
```python
def arrayPairSum(self, nums: List[int]) -> int:
  sum = 0
  nums.sort()
  
  for i, n in enumerate(nums):
    # 짝수 번째 값의 합 계산
    if i % 2 == 0:
      sum += n
      
  return sum
```
<br><br>

#### 풀이3. 파이썬다운 방식
이 코드를 좀 더 정리할 수 있을까? 앞서 살펴본 슬라이싱을 활용하면 놀랍게도 단 한 줄로도 풀이가 가능하다.<br>
그야말로 파이썬다운 방식이다.
```python
def arrayPairSum(self, nums: List[int]) -> int:
  return sum(sorted(nums)[::2])
```
슬라이싱 구문 [::2]는 2칸씩 건너뛰므로 짝수 번째를 계산하는 것과 동일하다.

참고 | 문자열 슬라이싱 144p
<br><br>

#### 정리
풀이3 파이썬다운 방식이 가장 코드가 짧으면서도 슬라이싱을 사용한 덕분에 성능 또한 가장 좋다.<br>
풀이2 짝수 번째 계산도 매번 min()을 계산하지 않고 단순히 해당 인덱스를 찾기만 하면 되므로 풀이1 오름파순 풀이에 비해 좀 더 성능이 좋은 편이다.
<br><br>

---

### 문제 11 자신을 제외한 배열의 곱
>193p

* **내가 짠 코드**<br>
생각 안 나서 풀이 봄
<br><br>

### 문제 11 자신을 제외한 배열의 곱 풀이
#### 풀이1. 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
이 문제에는 중요한 제약사항이 있다. '나눗셈을 하지 않고 O(n)에 풀이하라'는 점인데 이 말은 당장 머릿속에 떠오르는 풀이법인, 미리 전체 곱셈 값을 구해놓고 각 항목별로 자기 자신을 나눠서 풀이하는 방법은 안 된다는 뜻이기도 하다.<br>
그렇다면 풀이 방법은 한 가지 뿐이다. 자기 자신을 제외하고 왼쪽의 곱셈 결과와 오른쪽의 곱셈 결과를 곱해야 한다.

먼저 왼쪽부터 곱해서 result에 추가한다. 곱셈 결과는 그대로 out 리스트 변수에 담기게 되며, 마지막 값 곱셈을 제외하여 결과는 [1, 1, 2, 6]이 된다.<br>
코드로 구현하면 다음과 같다.
```python
p = 1
for i in range(0, len(nums)):
  out.append(p)
  p = p * nums[i]
```
이처럼 변수 i가 오른쪽으로 이동하면서 해당 인덱스의 값을 곱해 나간 다음, 오른쪽에서 곱해서 넣는다.<br>
여기서 만약 별도의 리스트 변수를 만들고 그 변수에 우측 곱셈 결과를 넣으면, 공간 복잡도는 O(n)이 된다.<br>
그러나 기존 out 변수를 재활용한다면 공간 복잡도 O(1)에 풀이가 가능하다.<br>
참고로 출력에 필요한 공간은 공간 복잡도에 포함하지 않는다.
<br><br>

```python
p = 1
for i in range(len(nums) - 1, 0 - 1, -1):
  out[i] = out[i] * p
  p = p * nums[i]
```
이번에는 왼쪽의 곱셈 결과에 오른쪽 마지막 값부터 차례대로 곱해 나간다.<br>
for 문의 range(x, y, z)에서 세 번째 파라미터인 z는 증분을 지정하는 파라미터며, 여기서는 -1이므로 1씩 줄어드는 형태가 된다.<br>
또한 여기서 p는 1부터 차례대로 점점 커지면서 4, 12, 24가 되고, 최종적으로 이 값이 왼쪽 곱셈 결과에 곱해져 out 변수에는 정답인 [24, 12, 8, 6]을 담게 된다.<br>
그림 7-11(193p)에 이 과정이 잘 나와 있으며, 전체 코드는 다음과 같다.
```python
def productExceptSelf(self, nums: List[int]) -> List[int]:
  out = []
  p = 1
  # 왼쪽 곱셈
  for i in range(0, len(nums)):
    out.append(p)
    p = p * nums[i]
  p = 1
  # 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
  for i in range(len(nums) - 1, 0 - 1, -1):
    out[i] = out[i] * p
    p = p * nums[i]
  return out
```

---

### 문제 12 주식을 사고팔기 가장 좋은 시점
> 195p

* **내가 짠 코드**<br>
```python
def stock(nums:list) -> int:
  max = 0

  for i in range(len(nums)):
    for j in range(i+1,len(nums)):
      sub = nums[j] - nums[i]
      if max < sub:
        max = sub

  return max


nums = list(map(int,input().split()))
print(stock(nums))
```
<br><br>

### 문제 12 주식을 사고팔기 가장 좋은 시점 풀이
#### 풀이1. 브루트 포스로 계산
가장 먼저 접근할 풀이법은 당연히 브루트 포스다. 처음부터 O(n^2)으로 사고팔고를 반복하면, 마지막에 최대 이익을 산출할 수 있을 것 같다.
```python
def maxProfit(self, prices: List[int]) -> int:
  max_price = 0
  
  for i, price in enumerate(prices):
    for j in range(i, len(prices)):
      max_price = max(prices[j] - price, max_price)
      
  return max_price
```
하지만, 안타깝게도 이 풀이는 타임아웃으로 풀리지 않는다. 좀 더 효율적인 풀이가 필요하다.
<br><br>

#### 풀이2. 저점과 현재 값과의 차이 계산
입력값 [7, 1, 5, 3, 6, 4]을 그림 7-12(196p)와 같이 그래프로 그려보자.<br>
이처럼 값을 그래프로 나열해서 시각화해보면 대략 어떤 식으로 풀어야 할지 직관이 생길 것이다.<br>
현재값을 가리키는 포인터가 우측으로 이동하면서 이전 상태의 저점을 기준으로 가격 차이를 계산하고, 만약 클 경우 최댓값을 계속 교체해나가는 형태로 O(n) 풀이가 가능할 것 같다.

이제 다음과 같이 최댓값, 최솟값을 선언해보자.
```python
profit = -sys.maxsize
min_price = sys.maxsize
```
최댓값이 되어야 할 profit 변수와 최솟값이 되어야 할 min_price 변수의 초깃값은 이처럼 각각 시스템의 가장 작은 값, 가장 큰 값으로 정한다.<br>
즉 최댓값 변수는 최솟값으로, 최솟값 변수는 최댓값으로 지정한다. 그래야 어떤 값이 들어오든 바로 교체될 수 있기 때문이다.<br>
만약 None으로 잡아두게 되면 비교 시 타입 에러(TypeError)가 발생할 수 있기 때문에 이처럼 최솟값, 최댓값은 시스템의 최댓값, 최솟값으로 설정하는 게 편하다.

단 이 문제에서는 최대 이익 profit이 나중에 최종 결과로 리턴되는데, 입력값이 []인 경우, 즉 빈 배열인 경우에는 자칫 -sys.maxsize가 그대로 리턴될 수 있기 때문이다.
```python
profit = 0
min_price = sys.maxsize
```
여기서는 이와 같이 0으로 설정해본다.<br>
어차피 최댓값은 0보다는 항상 커야 하기 때문이다. 이후 최저점과 비교해 더 작을 경우 최솟값을 갱신하고, 현재 값과 최솟값과의 차이를 계산해 만약 더 클 경우 최댓값 profit을 계속 갱신하면서 반복한다.

이제 전체 코드는 다음과 같다.
```python
def maxProfit(self, prices: List[int]) -> int:
  profit = 0
  min_price = sys.maxsize
  
  # 최솟값과 최댓값을 계속 갱신
  for price in prices:
    min_price = min(min_price, price)
    profit = max(profit, price - min_price)
    
  return profit
```
<br><br>

#### 참고. 최댓값과 최솟값
최댓값과 최솟값의 초깃값을 지정하는 방법에는 여러 가지가 있다.<br>
최댓값에는 가장 낮은 값을 초깃값으로 해야 어떤 값이든 최댓값이 교체될 수 있고 반대로 최솟값에는 가장 높은 값을 초깃값으로 해야 어떤 값이든 최솟값이 바로 교체될 수 있다.<br>
앞서 문제 풀이에는 다음과 같이 sys를 활용했다. 이 모듈을 사용하면 시스템이 지정할 수 있는 가장 높은 값, 낮은 값을 활용할 수 있다.
```python
mx = -sys.maxsize
mn = sys.maxsize
```
<br>

flaot()을 이용해 다음과 같이 무한대 값을 지정하는 방법도 있다.
```python
mx = float('-inf')
mn = float('inf')
```
<br>

가장 좋지 않은 방법은 다음과 같이 가장 큰 값을 설정해야 하는데 999999와 같은 임의의 값을 지정하는 것이다. 이렇게 할 경우, 문제가 생길 수 있다.
```python
mn = 999999
```


