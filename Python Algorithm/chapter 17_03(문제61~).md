# 목차

# 17장. 정렬
## 문제 61 가장 큰 수
* 항목들을 조합하여 만들 수 있는 가장 큰 수를 출력하라.
* 입력
```
[10, 2]
```
* 출력
```
"210"
```

<br>

* 입력
```
[3, 30, 34, 5, 9J
```
* 출력
```
"9534330"
```

<br><br>

* **내가 짠 코드**<br>
```python

```

<br><br>

## 문제 61 가장 큰 수 풀이
### 풀이1. 삽입 정렬
이 문제는 각 요소 단위로 크기 순으로 정렬하면 된다.<br>
단, 여기서는 다소 특이한 정렬 기법을 적용해야 하는데 맨 앞에서부터 자릿수 단위로 비교해서 크기 순으로 정렬한다.<br>
즉 9는 30보다 맨 앞자리 수가 더 크므로 9가 더 앞에 와야 한다.<br>
좀 더 쉽게 비교하려면 930이 큰지 309가 큰지 비교하는 문제로 풀 수 있을 것 같다. <br>
즉 a + b와 b + a를 비교하는 형태로 다음과 같이 처리할 수 있다.
```python
def to_swap(n1: int, n2: int) -> bool:
    return str(n1) + str(n2) < str(n2) + str(n1)
```
이 함수의 결과가 True라면 위치 변경이 이뤄져야 한다.<br>
앞서 삽입 정렬을 열심히 풀어봤으니, 리스트 17-4과 같은 수도코드를 참고하여 이 문제도 삽입 정렬로 다시 한번 풀이해보자.
* **리스트 17-4** 삽입 정렬 수도코드
```
i ← l
while i < length(A)
    j ← l
    while j > 0 and A[j-1] > A[j]
        swap A[j] and A[j-1]
        j ← j - 1
    end while
    i ← i + 1
end while
```
앞서 삽입 정렬을 구현해봤음에도 위키피디아의 수도코드를 다시 구현하는 이유는 앞서 문제의 풀이는 연결 리스트에 대한 풀이이고, 이 문제는 배열이기 때문에 인덱스를 지정할 수 있어서 전반적으로 코드가 많이 달라지기 때문이다.<br>
대부분의 알고리즘 책에서도 배열 풀이를 기본으로 하고 있고, 위키피디아에서도 배열로 풀 수 있는 수도코드를 제공하므로, 이 문제 또한 배열로 새롭게 구현하는 형태로 풀이해보자.<br>
다음과 같이 수도코드를 파이썬 코드로 구현할 수 있다.
```python
def largestNumber(self, nums: List[int]) -> str:
    i = 1
    while i < len(nums):
        j = i
        while j > 0 and self.to_swap(nums[j - 1], nums[j]):
            nums[j], nums[j - 1] = nums[j - 1], nums[j]
            j -= 1
        i += 1
        ...
```




























