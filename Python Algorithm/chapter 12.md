# 목차
* [출처](#출처)
<br><br><br>


# 12장 그래프
> 수학에서, 좀 더 구체적으로 그래프 이론에서 그래프란 객체의 일부 쌍(Pair)들이 '연관되어' 있는 객체 집합 구조를 말한다.

<br><br>

## 그래프 이론의 유래
지금으로부터 300여 년 전 프로이센 공국의 쾨니히스베르크(Königsberg)에는 프레겔 강이 흐르고 있었다.<br>
프레겔 강에는 2개의 큰 섬이 있었고, 섬과 도시를 연결하는 7개 다리가 놓여 있었다(그림 12-1(318p)은 오일러 시대의 쾨니히스베르크 지도다. 여기서는 6개의 다리만 보이는데, 마지막 1개는 이 그림이 그려지던 시기에는 아직 건설되기 전으로 보인다).<br>
어느날 도시의 시민 한 명이 "이 7개 다리를 한 번씩만 건너서 모두 지나갈 수 있을까?"라는 흥미로운 문제를 냈다.<br>
그러나 쉽게 풀릴 것처럼 보였던 이 문제를 풀 수 있는 이는 아무도 없었다.

'수학의 모차르트'라 불리는 레온하르트 오일러가 '쾨니히스베르크의 다리 문제'를 조사하기 시작했다.<br>
오일러는 이 문제가 도형 문제처럼 보이지만, 당시까지 알려진 기하학으로는 풀 수 없음을 알았다.<br>
그리고 미지의 영역에 그 해법이 있다는 사실을 천재적인 직관으로 간파했다.

이것이 바로 '그래프 이론'의 시작이다.

> 그림 12-1 오일러 시대의 쾨니히스베르크 지도

<br><br>
## 오일러 경로
그렇다면 오일러는 쾨니히스베르크 다리 문제를 풀었을까?<br>
오일러는 이 문제를 다음 그림 12-2(318p)와 같은 형태로 각각의 다리에 a부터 g까지 이름을 부여하고 도식화해 1735년에 논문을 발표했다.

> 그림 12-2 18세기 오일러가 논문에서 직접 그린 쾨니히스베르크 다리 스케치

논문에 포함된 이 스케치는 현대에 이르러 그래프 구조의 원형이 되었다.<br>
오일러의 스케치를 현대식 그래프 구조에 따라 나타낸 그림 12-3(319p)에서는 A부터 D까지를 정점(Vertex), a부터 g까지는 간선(Edge)으로 구성된 그래프라는 수학적 구조를 찾아볼 수 있다.<br>

> 그림 12-3 쾨니리스베르크 다리의 그래프 구조

오일러는 모든 정점이 짝수 개의 차수(Degree)를 갖는다면 모든 다리를 한 번씩만 건너서 도달하는 것이 성립한다고 말했다.<br>
그로부터 100년이 훨씬 더 지난 1873년, 독일의 수학자 칼 히어홀저(Carl Hierholzer)가 이를 수학적으로 증명해낸다.<br>
이를 '오일러의 정리(Euler's Theorem)'라 부른다.

아울러 모든 간선을 한 번씩 방문하는 유한 그래프(Finite Graph)를 일컬어 오일러 경로(Eulerian Trail/Eulerian Path)라 부르며, 어려서부터 즐겨 하던 놀이 중 하나인 '한붓 그리기'라고도 말한다.<br>
글자 그대로 한 번도 붓을 떼지 않고 모든 간선을 한 번씩만 그릴 수 있는지를 의미한다.<br>
그리고 마지막으로 가장 중요한 사항으로, 증명에 따르면 쾨니히스베르크의 다리는 모든 정점이 짝수개의 차수를 갖지 않으므로(심지어 짝수개의 차수를 갖는 정점은 하나도 없다) 오일러 경로가 아니다.
<br><br>

## 오일러 경로와 오일러 회로
**오일러 경로**란 그래프에 존재하는 모든 Edge를 정확히 1번씩만 방문하는 연속된 경로이다.<br>
이때 시작점과 도착점이 같으면 **오일러 회로**가 된다.

<img src="https://user-images.githubusercontent.com/55045377/117661166-fbc55d00-b1d8-11eb-8656-39d70c2a4f84.png" width=50% height=50%>

> 오일러 회로

가장 대표적으로 별 모양 그래프가 있는데 어느 점에서 시작하더라도 모두 출발점으로 되돌아 올 수 있다.<br>
즉 위 그래프는 오일러 회로가 존재한다.<br>
위 그래프를 다시 보면 모든 정점의 차수가 2(짝수)인데 시작점과 끝점을 제외하고서는 들어오는 간선이 있다면 반드시 나가는 간선이 하나 더 마련되어 있어야 하기 때문이다.<br>
그렇게 때문에 항상 차수가 2의 배수꼴로 붙게 된다.

오일러 경로의 존재 여부를 판단하는 방법은, 무향 그래프일 경우 Degree가 홀수인 정점이 2개일 때 오일러 경로가, 0개일 때 오일러 회로가 존재한다.

<img src="https://user-images.githubusercontent.com/55045377/117661604-84dc9400-b1d9-11eb-9d2c-58f7270a134d.png" width=50% height=50%>

> 오일러 경로는 존재하지만 오일러 회로는 존재하지 않는 그래프

오일러 경로는 시작점과 끝점을 차수가 홀수인 정점 2개로 하며, 오일러 회로만 존재한다면 그 어떤 정점을 시작점으로 뽑아도 만드는 것이 가능하다.
<br><br>

## 해밀턴 경로
> 해밀턴 경로는 각 정점을 한 번씩 방문하는 무향 또는 유향 그래프 경로를 말한다.

해밀턴 경로(Hamiltonian Path)가 오일러 경로의 차이점을 들자면, 오일러 경로는 간선을 기준으로 하고 해밀턴 경로는 정점을 기준으로 한다는 점이다.<br>
그러나 이러한 단순한 차이에도 불구하고 놀랍게도 해밀턴 경로를 찾는 문제는 최적 알고리즘이 없는 대표적인 NP-완전 문제다.(NP 문제 중 NP-난해(Hard)인 문제를 NP-완전 문제라 부른다)

원래의 출발점으로 돌아오는 경로는 특별히 해밀턴 순환(Hamiltonian Cycle)이라 하는데, 이중에서도 특히 최단 거리를 찾는 문제는 알고리즘 분야에서는 외판원 문제(Travelling Salesman Problem)(흔히 약어로 간단히 TSP라고 칭한다)로도 더욱 유명하다.<br>
외판원 문제란 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제, 즉 최단 거리인 해밀턴 순환을 찾는 문제이며, NP-난해 문제로 이론 컴퓨터과학 분야의 매우 중요한 문제 중 하나이기도 하다.

> 그림 12-4

외판원 문제를 좀 더 살펴보자. 그림 12-4(320p)에 각 도시의 위치가 표시된 미국 지도가 있다.<br>
각 도시를 한 번씩 방문한다고 했을 때, 어떤 순서로 방문해야 가장 짧은 거리가 될까?<br>
만약 도시가 20개라고 할 때 이 문제의 정답을 찾기 위해 다녀야 하는 총 경로의 수는 20!다.<br>
이 값은 얼마나 될까?<br>
20! = 2,432,902,008,176,640,000이다.<br>
그러니까 약 240경 번의 경로를 다녀봐야 가장 짧은 경로를 찾을 수 있다.<br>
문제는 단순하지만 정답은 실로 엄청나다.
<br><br>

## 참고. NP 복잡도
321p 참고
<br><br>

---

외판원 문제는 23장에서 살펴보게 될 다이나믹 프로그래밍 기법을 활용하면 좀 더 최적화할 수 있다.<br>
이 경우 O(n^2 2^n)로 최적화할 수 있는데, 앞서 n=20의 경우 419,430,400로, 여전히 엄청난 수치이긴 하지만 240경 번이었던 이전에 비해서는 훨씬 더 빠르게 계산할 수 있다.
<br><br>

## 그래프 순회
> 그래프 순회란 그래프 탐색(Search)이라고도 불리우며 그래프의 각 정점을 방문하는 과정을 말한다.

그래프의 각 정점을 방문하는 그래프 순회(Graph Traversals)에는 크게 깊이 우선 탐색(Depth-First Search)(이하 DFS)과 너비 우선 탐색(Breadth-First Search)(이하 BFS)의 2가지 알고리즘이 있다.<br>
DFS는 19세기 프랑스의 수학자 찰스 피에르 트레모가 미로 찾기를 풀기 위한 전략을 찾다가 고안한 것으로 알려져 있으며, 일반적으로 BFS에 비해 더 널리 쓰인다.<br>
코딩 테스트 시에도 대부분의 그래프 탐색은 DFS로 구현하게 될 것이다.

DFS는 주로 스택으로 구현하거나 재귀로 구현하며, 이후에 살펴볼 백트래킹을 통해 뛰어난 효용을 보인다.<br>
반면, BFS는 주로 큐로 구현하며, 그래프의 최단 경로를 구하는 문제 등에 사용된다.<br>
13장에서는 40번 '네크워크 딜레이 타임' 문제를 통해 다익스트라 알고리즘으로 최단 경로를 찾는 문제에서 BFS로 구현하는 코드를 살펴보게 될 것이다.

그렇다면 여기서는 먼저 그림 12-7(323p)과 같은 순회 그래프를 한번 살펴보자.

> 그림 12-7

그래프를 표현하는 방법에는 크게 인접 행렬(Adjacency Matrix)과 인접 리스트(Adjacency List)의 2가지 방법이 있는데, 여기서는 이 그림 12-7(323p)의 그래프를 인접 리스트로 표현할 것이다.<br>
인접 리스트는 출발 노드를 키로, 도착 노드를 값으로 표현할 수 있다.<br>
도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다.<br>
파이썬의 딕셔너리 자료형으로 다음과 같이 나타낼 수 있다.
```python
graph = {
    1: [2, 3, 4],
    2: [5],
    3: [5],
    4: [],
    5: [6, 7],
    6: [],
    7: [3],
}
```
이제 이 딕셔너리를 입력값으로 해서 각각 DFS, BFS를 구현해보고 어떤 결과가 나오는지 살펴보자.
<br><br>

## DFS(깊이 우선 탐색)
먼저, DFS부터 구현해보자.<br>
일반적으로 DFS는 스택으로 구현하며, 재귀를 이용하면 좀 더 간단하게 구현할 수 있다.<br>
코딩 테스트 시에도 재귀 구현이 더 선호되는 편이다.
<br><br>

### 재귀 구조로 구현
재귀를 이용한 DFS를 구현해보자.<br>
먼저, 위키피디아에 제시된 수도코드는 리스트 12-1(324p)과 같다.

> 리스트 12-1 재귀를 이용한 DFS 구현 수도코드

```
DFS(G, v)
    label v as discovered
    for all directed edges from v to w that are in G.adjacentEdges(v) do
        if vertex w is not labeled as discovered then
            recursively call DFS(G, w)
```
이 수도코드에는 정점 v의 모든 인접 유향(Directed) 간선들을 반복하라고 표기되어 있다.<br>
이 수도코드의 알고리즘을 동일하게 파이썬 코드로 구현해보면 다음과 같다.
```python
def recursive_dfs(v, discovered=[]):
    discovered.append(v)
    for w in graph[v]:
        if w not in discovered:
            discovered = recursive_dfs(w, discovered)
    return discovered
```
방문했던 정점, 즉 discovered를 계속 누적된 결과로 만들기 위해 리턴하는 형태만 받아오도록 처리했을 뿐 다른 부분들은, 예를 들어 변수명까지 동일하게 수도코드와 맞춰서 작성해봤다.<br>
이제 그림 12-7(323p) 그래프를 입력값으로 한 탐색 결과는 다음과 같다.
```python
>>> f'recursive dfs: {recursive_dfs(1)}'
'recursive dfs: [1, 2, 5, 6, 7, 3, 4]'
```
이 결과가 맞는지 확인하기 위해 그림 12-8과 같이 DFS를 직접 손으로 그려가며 결과를 확인해봤다.

> 그림 12-8

그림 12-8(325p)에서 막다른 곳에 도달할 때까지 연속으로 진행되는 탐색이 총 3번에 걸쳐 진행됐는데 1->2->5->6까지 진행하고 그다음 되돌아갔다가 다음번 탐색은 7->3, 다시 되돌아 나가 마지막으로 루트까지 거슬러 올라가서 4를 탐색하고 종료하게 된다.<br>
최종 결과는 1->2->5->6->7->3->4로 손으로 탐색한 결과가 코드의 실행 결과 [1, 2, 5, 6, 7, 3, 4]와 완전히 동일함을 확인할 수 있다.



















# 출처
* 오일러 경로와 오일러 회로 [[오일러 경로와 오일러 회로](#오일러-경로와-오일러-회로)]<br>
  https://rain-bow.tistory.com/entry/%EC%98%A4%EC%9D%BC%EB%9F%AC-%EA%B2%BD%EB%A1%9C%EC%99%80-%ED%9A%8C%EB%A1%9CEulerian-trail-circuit


