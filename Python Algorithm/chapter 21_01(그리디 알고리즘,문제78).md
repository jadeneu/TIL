# 목차

# 21장 그리디 알고리즘
> 585p

> 그리디 알고리즘(Greedy Algorithm)이란 바로 눈앞의 이익만을 좇는 알고리즘을 말한다.<br>
대부분의 경우에는 뛰어난 결과를 도출하지 못하지만, 드물게 최적해를 보장하는 경우도 있다.

그리디 알고리즘은 최적화 문제를 대상으로 한다.<br>
최적해를 찾을 수 있으면 그것을 목표로 삼고, 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는 것을 목표로 삼는다.<br>
따라서 그리디(탐욕이라는 뜻)라는 단어는 이 알고리즘의 원리에 잘 어울리는 단어다. 물론 대부분의 문제들은 이런 로컬 최적해(Locally Optimum Solution)를 찾는 탐욕스런 방법으로는 문제를 해결할 수 없다. <br>
그러나 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용한 알고리즘이기도 하다.

그리디 알고리즘이 잘 작동하는 문제들은 탐욕 선택 속성(Greedy Choice Property)을 갖고 있는 최적 부분 구조(Optimal Substructure)인 문제들이다. <br>
여기서 **탐욕 선택 속성이란** 앞의 선택이 이후 선택에 영향을 주지 않는 것을 말한다. <br>
다시 말해 그리디 알고리즘은 선택을 다시 고려하지 않는다.<br>
또한 **최적 부분 구조란** 문제의 최적 해결 방법이 부분 문제에 대한 최적 해결 방법으로 구성되는 경우를 말한다.

이렇게 탐욕 선택 속성과 최적 부분 구조의 2가지 조건을 만족하면 최적해를 찾을 수 있다.<br>
하지만 그렇지 않더라도 그리디 알고리즘은 정답을 근사하게 찾는 용도로 활용할 수 있으며, 대부분의 경우 계산 속도가 빠르므로 매우 실용적이다.

### 그리디 알고리즘 예
* 최단 경로 문제를 풀이하는 **다익스트라 알고리즘** → 최적해 보장
* 압축 알고리즘인 **허프만 코딩 알고리즘** (허프만 트리를 빌드할 때 쓰임) → 최적해 보장
* 의사결정 트리 알고리즘으로 유명한 **ID3 알고리즘** (머신러닝) → 최적해 보장 X

### 그리디 알고리즘과 다이나믹 프로그래밍의 차이
그리디 알고리즘은 최적 부분 구조 문제를 푼다는 점에서 흔히 다이나믹 프로그래밍과 비교되는데, 서로 풀 수 있는 문제의 성격이 다르며 알고리즘의 접근 방식 또한 다르다.<br>
**다이나믹 프로그래밍**이 하위 문제에 대한 최적의 솔루션을 찾은 다음, 이 결과들을 결합한 정보에 입각해 전역 최적 솔루션(Globally Optimum Solution)에 대한 선택을 한다면,<br>
이에 반해 **그리디 알고리즘**은 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태로, 서로 반대 방향으로 접근하는 구조를 띤다.

<br>

그렇다면 여기서는 그리디 알고리즘을 중심으로 풀 수 있는 문제, 다이나믹 프로그래밍으로 풀어야 하는 문제, 그리디 알고리즘으로는 풀 수 없는 문제들에 대해 차례대로 살펴보자.

<br><br>

## 배낭 문제
배낭 문제(Knapsack Problem)는 조합 최적화(Combinatorial Optimization) 분야의 매우 유명한 문제로, <br>
쉽게 말해 그림 21-1과 같이 배낭에 담을 수 있는 무게의 최댓값(15kg)이 정해져 있고 각각 짐의 가치($)와 무게(kg)가 있는 짐들을 배낭에 넣을 때 가치의 합이 최대가 되도록,<br>
즉 **$(달러)의 가치가 최대가 되도록 짐을 고르는 방법을 찾는 문제**다.

배낭 문제는 그림 21-1과 같이 짐을 쪼갤 수 있는 경우인 분할 가능 배낭 문제(Fractional Knapsack Problem)(그리디 알고리즘으로 해결)와 23장의 그림 23-5와 같이 짐을 쪼갤 수 없는 경우인 0-1 배낭 문제(다이나믹 프로그래밍으로 해결)로 나뉜다.

우선, 그림 21-1처럼 짐을 쪼갤 수 있는 분할 가능 배낭 문제부터 먼저 풀어보자.

<img src="https://user-images.githubusercontent.com/55045377/131242388-b5e1c970-9bfe-4a99-a933-2f5e7da61bf0.png" width=50% height=50%>

* **tip**<br>
여기에서는 단위 무게당 얻는 이익이 큰 것부터 배낭에 넣는다. → 즉 "가치($)/무게(kg)"가 큰 것부터 넣는다.

이 그림에서는 C의 단가가 2.5달러(10/4)로 가장 높으므로, C, B, E, D 순으로 총 8kg의 짐을 배낭에 담고 마지막 남은 7kg을 위해 A의 7/12 만큼을 쪼개서 배낭에 그리디 알고리즘으로 담는다.<br>
이렇게 하면 17.3 이라는 최적해를 찾을 수 있다. 

이 부분을 코드로 구현해보면 다음과 같다.
```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]

r = fractional_knapsack(cargo)
```
**(1) 먼저, 짐 cargo를 '(가격, 무게)'의 튜플 리스트로 정의하고, 함수 fractional_knapsack()을 호출한다.**

<br>

앞서 단가 기준으로 알고리즘을 설명한 그대로 구현하기 위해 **(2) 단가를 계산하고 역순으로 정렬한다.**<br>
즉 가장 단가가 높은 짐이 맨 위에 오도록 다음과 같이 구현한다.
```python
for c in cargo:
    pack.append((c[0] / c[1], c[0], c[1]))
pack.sort(reverse=True)
```

**(3) 이제 단가 순으로 그리디 알고리즘으로 계산하면 된다.** 전체 코드는 다음과 같다.
```python
def fractional_knapsack(cargo):
    capacity = 15
    pack = []
    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1]))
    pack.sort(reverse=True)
    
    # 단가 순 그리디 계산
    total_value: float = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2]
            total_value += p[1] * fraction
            break
            
    return total_value
```
이처럼 구현했을때 total_value는 17.3을 구할 수 있다. 앞서 알고리즘을 설명했을 때와 동일한 정답이다.

* **주의**<br>
그러나 이 문제에서 만약 짐을 쪼갤 수 없다면 지금까지 실행한 방식대로 단가 순으로 배치해선 안 된다.<br>
이와 같이 짐을 쪼갤 수 없는 0-1 배낭 문제는 23장 632페이지에서 풀이해본다.

<br><br>

## 동전 바꾸기 문제
또 다른 유명한 문제로 동전 바꾸기 문제(Coin-Change Problem)가 있다. 동전의 액면이 10원, 50원, 100원처럼 증가하면서 이전 액면의 배수 이상이 되면 그리디 알고리즘으로 풀 수 있다.<br>
우리나라 동전은 항상 배수 이상이므로 그리디로 풀 수 있다.

예를 들어 160원을 거슬러 준다면 10원짜리 16개보다는, 100원짜리 하나, 50원짜리 하나, 10원짜리 하나로, 각각의 동전을 최대한 활용하는 그리디한 방법이 **가장 작은 동전 개수로 거슬러줄 수 있는 방법**이다.

* **주의**<br>
그런데 만약 다른 나라에 갔더니 80원짜리 동전이 더 있다고 치자. 이 경우엔 더 이상 그리디하게 풀 수 없다.<br>
160원을 거슬러줘야 한다면 80원짜리 2개가 정답인데 그리디 알고리즘으로는 100원부터 선택하게 될 것이고 이렇게 하면 80원 2개로 풀이할 수 없기 때문이다.<br>
이 경우 앞서 0-1 배낭 문제와 마찬가지로 다이나믹 프로그래밍으로 풀어야 한다.

<br><br>

## 가장 큰 합
세 번째로는, 그리디 알고리즘의 실패 사례를 살펴보자. <br>
노드를 계속 더해가다가 마지막에 가장 큰 합이 되는 경로를 찾는 문제다. 일례로 그림 21-2를 살펴보자.

<img src="https://user-images.githubusercontent.com/55045377/131302140-a65e4146-6821-4b6f-a3eb-883520cdbdab.png" width=40% height=40%>

7부터 시작해 최종적으로 가장 큰 합을 만들기 위해서는 간선으로 연결된 2가지 선택지 중 더 큰 수를 계속 더해나가면 될 것 같다. <br>
그림 21-2는 전형적인 그리디 알고리즘의 형태로, 매번 가장 큰 값을 취해 나가면 7 -> 12 -> 6을 이어서 선택하게 된다.<br>
그런데 이 경우 합은 25에 불과하다. 만약 7에서 3을 택하고 99를 택하면 무려 109가 될 수 있다.<br>
그러나 그리디 알고리즘으로는 99를 발견할 수 없다. 7은 3과 12 중에서 절대로 3을 택하지 않을 것이기 때문이다.<br>
이 문제는 이진 트리를 정렬한다든지 등의 추가 작업을 하지 않는 한, 그리디 알고리즘으로는풀이할 수 없다.

이제 그리디 알고리즘으로 풀 수 있는 다른 문제를 살펴보자.

<br><br>

## 문제 78 주식을 사고팔기 가장 좋은 시점 II
> 590p

* 여러 번의 거래로 낼 수 있는 최대 이익을 산출하라.
* 입력
```
[7,1,5,3,6,4]
```
* 출력
```
7
```
* 설명<br>
1일 때 사서 5일 때 팔아 4의 이익을 얻고, 3일 때 사서 6일 때 팔아 3의 이익을 얻는다. 둘을 합하면 7이 된다.

<br><br>

* **내가 구현한 코드**<br>
```python
def solution(lst):
  max_p = 0

  for i in range(len(lst)-1):
    if lst[i] < lst[i+1]:             # 1
      max_p += lst[i+1] - lst[i]
    else:                             # 2
      continue
  
  return max_p

lst = [7,1,5,3,6,4]
print(solution(lst))
```
* **# 1**: `lst`의 현재 인덱스와 다음 인덱스 값을 비교해서 다음 인덱스 값이 더 크다면 두 값의 차를 `max_p`에 더한다.
* **# 2**: 아니라면 continue를 해서 다음 인덱스로 넘어간다.

<br><br>

## 문제 78 주식을 사고팔기 가장 좋은 시점 II 풀이
### 풀이1. 그리디 알고리즘



























