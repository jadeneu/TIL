# 목차

<br><br>

<img src="https://user-images.githubusercontent.com/55045377/115106591-a662ab00-9fa0-11eb-8f31-3d12b0b379a9.jpg">

4장 리뷰 시작!

---

# 4장 빅오, 자료형
## 빅오
* **정의**<br>
  빅오(O, big-O)란 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법이다.<br>
  (점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다)
  
  **-----------점근적 실행 시간이란-------------**<br>
  입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.<br>
  관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다.<br>
  충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.
  
* **설명**<br>
  빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 계수는 무시한다.
  
  예를 들어 입력값 n에 대해 4n^2+3n+4 번만큼 계산하는 함수가 있다면 이 함수의 시간 복잡도는 최고차항인 4n^2만을 고려한다.<br>
  즉 여기서의 시간 복잡도는 O(n^2)이 된다.
  
  빅오 표기법의 종류는 크게 다음과 같다.
  ```
  O(1) - O(logn) - O(n) - O(nlogn) - O(n^2) - O(2^n) - O(n!)
  ```
<br><br>

## 상한과 최악
* **설명**<br>
  **빅오(O)**는 상한을 의미한다.<br>
  이외에도 하한을 나타내는 **빅오메가**, 평균을 의미하는 **빅세타**가 있다.
  
  **----------------중요----------------**<br>
  한 가지 중요한 점은 상한을 최악의 경우와 혼동하는 것인데, <br>
  빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' 표현하는 방법일 뿐, <br>
  최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의해야 한다.
  
  좀 더 구체적으로 퀵 정렬을 예로 들어보자.<br>
  **- 최선의 경우**<br>
  입력값이 [1, 4, 3, 7, 8, 6, 5]일 때 퀵 정렬의 로무토 파티션 (로무토 파티션은 피벗을 정할 때 가장 우측을 택하는 가장 단순한 피벗 선택 방식이다)에서 이 입력값은 최선의 경우에 해당한다.<br>
  이 경우 모두 정렬하기 위해서는 총 18번의 비교 또는 스왑 연산이 필요하다.<br>
  n = 7이니 O(nlogn)에 가깝다.
  
  **- 최악의 경우**<br>
  입력값이 [1, 2, 3,4, 5, 6, 7]이라면, 48번의 연산을 수행한다.<br>
  이 경우가 바로 최악의 경우이며 O(n^2)에 가깝다. 
  
  **평균적으로는** 24번 사이를 왔다갔다 할 것이다.
  
  즉 n=7일 때 최선, 평균, 최악의 연산 횟수는 각각 18,24,48이며 이 값은 n이 점점 커져도 비슷한 비율로 유지될 것이다.<br>
  여기까지는 최선/평균/최악의 '경우'에 해당된다.
  <br><br>
  
  반면, 빅오 표기는 복잡한 함수 f(n)이 있을 경우, 이 함수의 실행 상한과 하한을 의미한다.

  즉 가장 빨리 실행될 때(하한), 가장 늦게 실행될 때(상한)를 뜻하며 이 중 가장 늦게 실행될 때를 **빅오(O)**, 가장 빨리 실행될 때를 **빅오메가**, 평균적으로는 **빅세타**로 지칭한다.
  <br><br>
  
  **---------------정리----------------**<br>
  다시 퀵 정렬의 예를 들자면 '최선의 경우 O(nlogn)이다.'<br>
  라는 말은 입력값이 [1, 4, 3, 7, 8, 6, 5]일 때 최대 연산이 nlogn 이내라는 이야기다.

  좀 더 말장난을 해보자면 '최선의 경우 O(n^2)이다.'라는 명제도 참이다. <br>
  빅오는 상한을 의미하므로 실제 연산 횟수가 이보다 작기만 하면 되기 때문이다.

  같은 이유로 '최선의 이유 O(n^3)이다.'라는 것도 말이 된다.

  하지만 이런 경우 상한을 지나치게 높게 설정했기 때문에 당연히 아무런 의미가 없다.

  다시 한번 정리하면,<br>
  **빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.**
<br><br>

## 분할 상환 분석
* **설명**<br>
  시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다.
<br><br>

## 병렬화
* **설명**<br>
  일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다.<br>
  최근에는 딥러닝의 인기와 함께 병렬화가 큰 주목을 받고 있으며 GPU는 병렬 연산을 위한 대표적인 장치이기도 하다.
  
  GPU 각각의 코어는 CPU보다 훨씬 더 느리지만 GPU의 코어는 수천여 개로 구성되어 있어, 많아 봐야 수십여 개에 불과한 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.

  알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이기도 하다.
<br><br>

## 파이썬 자료형
(107p 주요 자료형 계층 구조 참고)
<br><br>

## 숫자
* **설명**<br>
  파이썬에서는 숫자 정수형으로 int만을 제공한다.
  
  +<br>
  bool은 엄밀히 따지면 논리 자료형인데 파이썬에서는 내부적으로 1(True)과 0(False)으로 처리되는 int의 서브 클래스이다.<br>
  int는 object의 하위 클래스이기도 하기 때문에 결국 다음과 같은 구조를 띤다.
  ```
  object > int > bool
  ```
<br><br>

## 매핑
* **정의**<br>
매핑(Mapping) 타입은 키와 자료형으로 구성된 복합 자료형이며, 파이썬에 내장된 유일한 매핑 자료형은 바로 딕셔너리다.
<br><br>

## 집합
* **정의**<br>
파이썬의 집합 자료형인 set은 중복된 값을 갖지 않는 자료형이다.

* **설명**<br>
  파이썬에서 빈 집합은 다음과 같은 형태로 선언한다.
  ```python
  >>> a = set()
  >>> a
  set()
  >>> type(a)
  <class 'set'>
  ```
  빈 집합이 아닌 값이 포함된 집합을 선언할 때는 a = {1, 2, 3} 형태로 하는데, <br>
  집합은 딕셔너리와 동일하게 중괄호({ })를 사용하므로 이 점에 유의해야 한다.
  
  **- 집합과 딕셔너리 구분하는 법**<br>
  딕셔너리는 키(Key)/값(Value) 형태이지만, <br>
  집합은 값만 선언한다. ↓↓↓
  ```python
  >>> a = {'a','b','c'}
  >>> type(a)
  <class 'set'>
  >>> a = {'a':'A', 'b':'B', 'c': 'C'}
  >>> type(a)
  <class 'dict'>
  ```
  +<br>
  set은 입력 순서가 유지되지 않으며, 다음처럼 중복된 값이 있을 경우 하나의 값만 유지한다.
  ```python
  >>> a ={3, 2, 3, 5}
  >>> a
  {2, 3, 5}
  ```
<br><br>

## 시퀀스
* **정의**<br>
  시퀀스(Sequence)는 우리말로 하면 '수열' 같은 의미로, <br>
  어떤 특정 대상의 순서 있는 나열을 뜻한다.

  예를 들어 str은 문자의 순서 있는 나열로 문자열을 이루는 자료형이며, <br>
  list는 다양한 값들을 배열 형태의 순서 있는 나열로 구성하는 자료형이다.<br>
  (파이썬에서는 list라는 시퀀스 타입이 사실상 배열의 역할을 수행한다)

* **설명**<br>
  시퀀스는 불변과 가변으로 구분하는데 말 그대로 불변은 값을 변경할 수 없다.<br>
  여기에는 str, tuple, bytes가 해당되는데 한번 이 타입으로 선언되는 값은 변경할 수가 없다.

  한편, 'str 변수는 값을 변경할 수 있는데?' 라는 의문이 들 수 있다. 다음 코드를 살펴보자.
  ```python
  >>> a = 'abc'
  >>> id('abc')
  4317530408
  >>> id(a)
  4317530408
  >>> a = 'def'
  >>> id('def')
  4318831648
  >>> id(a)
  4318831648
  ```
  각각의 메모리 주소를 출력해보면 a 변수는 처음에는 abc를 참조했다가 이후에는 def를 참조하도록 변경되었을 뿐이다.<br>
  abc와 def는 생성된 후에 변하지 않고 메모리 어딘가에 남아 있다. <br>
  str이 정말로 변경되려면 참조하고 있는 str에 대해 다음과 같은 할당자가 처리되어야 하는데 여기서는 오류가 발생한다.
  ```python
  >>> a[1] = 'd'
  ```
  > 자세한 오류 결과는 111p 참고
  
  이처럼 str은 변경할 수 없으며, 불변이다. 

  반면 list는 가변이다. <br>
  이 말은 쉽게 이해된다. 리스트는 자유롭게 값을 추가, 삭제할 수 있는 동적 배열이다.
<br><br>




























