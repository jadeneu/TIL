# 목차

<br><br>

<img src="https://user-images.githubusercontent.com/55045377/115106591-a662ab00-9fa0-11eb-8f31-3d12b0b379a9.jpg">

4장 리뷰 시작!

---

# 4장 빅오, 자료형
## 빅오
* **정의**<br>
  빅오(O, big-O)란 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법이다.<br>
  (점근적 실행 시간을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나다)
  
  **-----------점근적 실행 시간이란-------------**
  입력값 n이 커질 때, 즉 입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.<br>
  관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다.<br>
  충분히 큰 입력에서는 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다.
  
* **설명**<br>
  빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 계수는 무시한다.
  
  예를 들어 입력값 n에 대해 4n^2+3n+4 번만큼 계산하는 함수가 있다면 이 함수의 시간 복잡도는 최고차항인 4n^2만을 고려한다.<br>
  즉 여기서의 시간 복잡도는 O(n^2)이 된다.
  
  빅오 표기법의 종류는 크게 다음과 같다.
  ```
  O(1) - O(logn) - O(n) - O(nlogn) - O(n^2) - O(2^n) - O(n!)
  ```
<br><br>

## 상한과 최악
* **설명**<br>
  **빅오(O)**는 상한을 의미한다.<br>
  이외에도 하한을 나타내는 **빅오메가**, 평균을 의미하는 **빅세타**가 있다.
  
  **----------------중요----------------**<br>
  한 가지 중요한 점은 상한을 최악의 경우와 혼동하는 것인데, <br>
  빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 '적당히 정확하게' 표현하는 방법일 뿐, <br>
  최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이라는 점에 유의해야 한다.
  
  좀 더 구체적으로 퀵 정렬을 예로 들어보자.<br>
  **- 최선의 경우**<br>
  입력값이 [1, 4, 3, 7, 8, 6, 5]일 때 퀵 정렬의 로무토 파티션 (로무토 파티션은 피벗을 정할 때 가장 우측을 택하는 가장 단순한 피벗 선택 방식이다)에서 이 입력값은 최선의 경우에 해당한다.<br>
  이 경우 모두 정렬하기 위해서는 총 18번의 비교 또는 스왑 연산이 필요하다.<br>
  n = 7이니 O(nlogn)에 가깝다.
  
  **- 최악의 경우**<br>
  입력값이 [1, 2, 3,4, 5, 6, 7]이라면, 48번의 연산을 수행한다.<br>
  이 경우가 바로 최악의 경우이며 O(n^2)에 가깝다. 
  
  **평균적으로는** 24번 사이를 왔다갔다 할 것이다.
  
  즉 n=7일 때 최선, 평균, 최악의 연산 횟수는 각각 18,24,48이며 이 값은 n이 점점 커져도 비슷한 비율로 유지될 것이다.<br>
  여기까지는 최선/평균/최악의 '경우'에 해당된다.
  <br><br>
  
  반면, 빅오 표기는 복잡한 함수 f(n)이 있을 경우, 이 함수의 실행 상한과 하한을 의미한다.

  즉 가장 빨리 실행될 때(하한), 가장 늦게 실행될 때(상한)를 뜻하며 이 중 가장 늦게 실행될 때를 **빅오(O)**, 가장 빨리 실행될 때를 **빅오메가**, 평균적으로는 **빅세타**로 지칭한다.
  
  **---------------정리----------------**
  다시 퀵 정렬의 예를 들자면 '최선의 경우 O(nlogn)이다.'<br>
  라는 말은 입력값이 [1, 4, 3, 7, 8, 6, 5]일 때 최대 연산이 nlogn 이내라는 이야기다.

  좀 더 말장난을 해보자면 '최선의 경우 O(n^2)이다.'라는 명제도 참이다. <br>
  빅오는 상한을 의미하므로 실제 연산 횟수가 이보다 작기만 하면 되기 때문이다.

  같은 이유로 '최선의 이유 O(n^3)이다.'라는 것도 말이 된다.

  하지만 이런 경우 상한을 지나치게 높게 설정했기 때문에 당연히 아무런 의미가 없다.

  다시 한번 정리하면,<br>
  **빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.**
<br><br>

## 분할 상환 분석
* **설명**<br>
  시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 분할 상환 분석 방법이 등장하는 계기가 됐다.
<br><br>

# 병렬화
* **설명**<br>
  일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다.<br>
  최근에는 딥러닝의 인기와 함께 병렬화가 큰 주목을 받고 있으며 GPU는 병렬 연산을 위한 대표적인 장치이기도 하다.
  
  GPU 각각의 코어는 CPU보다 훨씬 더 느리지만 GPU의 코어는 수천여 개로 구성되어 있어, 많아 봐야 수십여 개에 불과한 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.

  알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지는 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도 중 하나이기도 하다.
<br><br>

# 파이썬 자료형
(107p 주요 자료형 계층 구조 참고)
<br><br>





























