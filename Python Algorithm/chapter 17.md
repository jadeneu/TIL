# 목차

# 17장 정렬
> 정렬 알고리즘은 목록의 요소를 특정 순서대로 넣는 알고리즘이다. 대개 숫자식 순서(Numerical Order)와 사전식 순서(Lexicographical Order)로 정렬한다.

정렬(Sorting) 알고리즘은 간단하고 익숙할 뿐만 아니라 여러모로 유용하다.<br>
그러나 효율적으로 해결하기가 쉽지 않기 때문에, 컴퓨터과학 초기에 정렬은 많은 연구가 필요한 매력적인 주제 중 하나였다.<br>
뿐만 아니라 빅오, 분할 정복, 힙, 이진 트리, 시간과 공간의 트레이드오프(Time-Space Tradeoffs) 등 여러 가지 컴퓨터과학의 핵심 주제를 아우르기 때문에, 정렬은 알고리즘에 본격적으로 입문하기에도 매우 좋은 주제이기도 하다.

정렬은 알고리즘의 꽃이기도 하다.<br>
그 바탕을 구성하는 논리는 다른 코딩을 하는데도 많은 도움이 된다.<br>
그런 면에서 정렬을 실제로 구현할 일은 없을지언정, 공부를 통해 얻는 이득은 매우 크다. <br>
우리는 당장 내일 만들 무언가를 위해 기술을 익히는 용도로 공부를 하기도 하지만, 장기적인 관점에서 미래를 위한 꾸준히 기본기를 다져나가는 학습도 필요하기 때문이다.
<br><br>

## 버블 정렬
사실 따지고 보면, 버블 정렬은 전혀 중요한 알고리즘이 아니다.<br>
정렬 자체가 실무와는 다소 거리가 있기도 하지만 그중에서도 버블 정렬은 더욱 거리가 먼 알고리즘이다.<br>
전혀 중요하지 않다. 왜 중요하지 않다고 이야기했는지 아래 설명을 보자.

* **리스트 17-1** 버블 정렬 수도 코드<br>

  ```
  Bubblesort(A)
      for i from 1 to A.length
          for j from 0 to A.length - 1
              if A[j] > A[j + 1]
                  swap a[j] with a[j + 1]
  ```
리스트 17-1 의 수도코드를 보면 금방 알 수 있다.<br>
이 알고리즘은 n번의 라운드로 이뤄져 있으며, 각 라운드마다 배열의 아이템을 한 번씩 쭉 모두 살펴본다.<br>
연달아 있는 아이템 2개의 순서가 잘못되어 있는 것을 발견하면, 두 아이템을 맞바꾼다.<br>
배열 전체를 쭉 살펴보는 것을 n번 하기 때문에 시간 복잡도는 항상 O(n^2) 이다. <br>
이보다 더 비효율적일 수는 없으며 구현 가능한 가장 느린 정렬 알고리즘이다.

물론 스왑이 이뤄지지 않았는지 여부를 확인해 n^2보다 좀 더 최적화할 수 있지만, 그럼에도 다른 정렬 알고리즘과는 여전히 성능 차이가 있다.<br>
그래서 앞서, 중요하지 않은 알고리즘이라 거듭 강조한 것이다.
수도코드를 살펴 봤으니 이제 파이썬 구현은 가볍게 해볼 수 있을 것 같다.

```python
def bubblesort(A):
    for i in range(1, len(A)):
        for j in range(0, len(A) - 1):
            if A[j] > A[j + 1]:
                A[j], A[j + 1] = A[j + 1], A[j]
```
수도코드를 파이썬 코드로 직접 구현해봤다.<br>
i와 j를 비교하는 순서는 앞에서부터 할 수 있고 뒤에서부터 할 수도 있다.<br>
"Introduction to Algorithms" 책에서는 뒤에서부터 비교하도록 수도코드를 제시 하고 있으나, 여기서는 앞에서부터 비교를 진행했다. 큰 차이는 없다.
<br><br>

## 병합 정렬
병합 정렬(Merge Sort)은 컴퓨터과학 역사상 최고의 천재라 일컬어지는 존 폰 노이만(John von Neumann)이 194 5년에 고안한 알고리즘으로, 분할 정복(Divide and Conquer) (22장 참조)의 진수를 보여주는 알고리즘이다.<br>
최선과 최악 모두 O(n log n)인 사실상 완전한 θ(n log n)으로 일정한 알고리즘이며, 대부분의 경우 퀵 정렬보다는 느리지만 일정한 실행 속도뿐만 아니라 무엇보다도 안정 정렬(Stable Sort)이라는 점에서 여전히 상용 라이브러리에 많이 쓰이고 있다.<br>
곧 풀어볼 58번 문제에서도, 병합 정렬의 고른 성능 덕분에 퀵 정렬로도 풀리지 않던 문제가 병합 정렬로는 잘 풀리는 경우를 확인하게 될 것이다.<br>
간단히 그림 17-3에서 병합 정렬의 도식화만 살펴보자.


























