# 목차


# 11장 해시 테이블
> 해시 테이블 또는 해시 맵은 키를 값에 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 점이다.<br>
덕분에 데이터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있다.<br>
해시 테이블은 지금까지도 현대 컴퓨터 프로그래밍 언어에서 유용하게 사용되는 매우 중요한 자료구조다.
<br><br>

## 해시
> 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말한다.

> 해시 함수는 임의의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환 시켜주는 함수

해시 테이블의 핵심은 해시 함수다. 여기서 입력값은 ABC, 1324BC, AF32B로 각각 3글자, 6글자, 5글자이지만, 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑된다.<br>
즉 **입력값의 길이가 달라도 출력값은 언제나 고정된 길이로 반환한다.**<br>
그리고 **동일한 값이 입력되면 언제나 동일한 출력값을 보장한다.**

여기서 화살표 역할을 하는 함수가 바로 해시 함수다.
```
ABC    -> A1
1324BC -> CB
AF32B  -> D5
```
<br><br>

## 해싱
해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱(Hashing)이라 하며, 해싱은 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나다.

대부분의 탐색 방법들은 탐색 키를 저장된 키 값과 반복적으로 비교하면서 탐색을 원하는 항목에 접근한다.<br>
반면 **해싱은 키 값에 직접 산술적인 연산을 적용**하여 항목이 저장되어 있는 **테이블의 주소를 계산하여 항목에 접근**한다. (해싱은 탐색 키의 비교가 아닌 탐색 키에 수식을 적용시켜서 바로 탐색 키가 저장된 위치를 얻음)<br>
이렇게 키 값의 연산에 의해 직접 접근이 가능한 구조를 **해시 테이블(hash table)** 이라 부르고, 해시 테이블을 이용한 탐색을 **해싱(hashing)** 이라 한다.

해싱은 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블(일반적으로 해시 테이블로 구현된다) 등의 자료구조를 구현하기에도 적합하다.<br>
이외에도 해시 함수는 체크섬(Checksum), 손실 압축, 무작위화 함수(Randomization Function), 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.<br>
그러나 어느 정도는 개념이 겹치긴 하지만, 서로 용도와 요구사항이 다른 만큼 각각 다르게 설계되고 최적화된다.

성능 좋은 해시 함수들의 특징은 다음과 같다.
* 해시 함수 값 충돌의 최소화
* 쉽고 빠른 연산
* 해시 테이블 전체에 해시 값이 균일하게 분포
* 사용할 키의 모든 정보를 이용하여 해싱
* 해시 테이블 사용 효율이 높을 것
<br><br>

## 생일 문제
그렇다면 충돌은 얼마나 많이 발생할까?<br>
생각보다 충돌은 쉽게 일어난다. 흔한 예로 생일 문제(Birthday Problem)를 들 수 있다.

생일의 가짓수는 365개(윤년 제외)이므로, 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면 비둘기집 원리(Pigeonhole Principle)에 따라 366명 이상이 모여야 일어나는 일 같다.<br>
하지만 실제로는 다음 그림과 같이 23명만 모여도 50%를 넘고, 57명이 모이면 그때부터는 99%를 넘어선다.

그림 11-1(281p)의 결과는 우리의 일반적인 상식에 반하는 내용이라 믿기지 않을 수도 있겠다. 그렇다면 실험을 통해 직접 확인해보자.<br>
생일 문제는 수식으로 증명하려면 상당히 어려운 계산이 필요하다.<br>
하지만 파이썬을 활용하면 간단한 실험을 통해서 어렵지 않게 증명할 수 있다.<br>
이러한 컴퓨터 실험을 통한 증명 방법은 1976년 4색 정리(지도에서 인접한 나라끼리 서로 다른 색을 칠하려면 4가지 색이면 충분하다는 정리)가 첫 번째 증명으로 가장 유명하며, 당시만 해도 고작 1,936개의 모델을 계산하는 데도 2대의 컴퓨터로 50일이 넘게 걸려 증명한 바 있다.

> 그림 11-1 모인 사람 수에 따라, 생일이 같은 2명이 존재할 확률

물론, 지금은 훨씬 더 강력한 컴퓨터를 이용해 확률을 쉽게 계산해낼 수 있다.<br>
이러한 기법들은 '해커를 위한 통계학(Statistics for Hackers)'이라 일컬으며 상당한 호응을 얻기도 했다.<br>
그렇다면 정말로 23명만 있으면 생일이 같을 확률이 50%를 넘어설 수 있을까?

다음과 같이 계산 코드를 작성해서 직접 실험해보자.
```python
import random

TRIALS = 100000 # 10만 번 실험
same_birthdays = 0 # 생일이 같은 실험의 수

# 10만 번 실험 진행
for _ in range(TRIALS):
    birthdays = []
    # 23명이 모였을 때, 생일이 같을 경우 same_birthdays += 1
    for i in range(23):
        birthday = random.randint(1, 365)
        if birthday in birthdays:
            same_birthdays += 1
            break
        birthdays.append(birthday)
        
# 전체 10만 번 실험 중 생일이 같은 실험의 확률
print(f'{same_birthdays / TRIALS * 100}%')
-------
50.708%
```
여기서는 23명이 모이는 경우를 각각 10만 번 실험했다. 그 결과, 생일이 같을 확률은 약 50.7%가 나왔다.<br>
정말로 23명만 모여도 생일이 같을 확률이 50%를 넘어선다. 실험을 통해 직접 확인할 수 있었다.

이처럼 일반적인 상식(잘못된 상식)과는 달리, 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요하다.
<br><br>

## 비둘기집 원리
> 비둘기집 원리란, n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리를 말한다.

왜 충돌은 일어날 수밖에 없을까? 비둘기집 원리는 충돌의 원리를 잘 설명한다. <br>
비둘기집 원리는 1834년 독일의 수학자 페터 디리클레(Peter Dirichlet)가  만든 것으로 '서랍 원리'라고도 불린다.<br>
간단한 귀류법으로 모순을 이끌어내 쉽게 증명할 수 있으며, 그림 11-2(282p)의 비둘기집 사진으로도 쉽게 이해된다.

> 그림 11-2

비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다.<br>
좋은 해시 함수라면 충돌을 최소화하여 단 1번의 충돌만 일어나게 하겠지만, 좋지 않은 해시 함수의 경우 심하면 9번을 모두 충돌해서, 9개의 공간 중 1개밖에 사용하지 못할 수도 있다.<br>
여러 번 충돌한다는 것은 그만틈 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.
<br><br>

## 로드 팩터
> 로드 팩터(Load Factor)란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.

→ *load factor = n/k*

로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다.<br>
또한 이 값은 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다.

자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며 '시간과 공간 비용의 적절한 절충안'이라고 얘기한다.<br>
일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하게 되며, 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.
<br><br>

## 해시 함수
그림 11-3(283p)은 해시 함수를 통해 키가 해시 값으로 변경되는 과정을 도식화한 것이다.

> 그림 11-3 해시 함수를 통해 키가 해시로 변경되는 과정

이처럼 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다.<br>
해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다.<br>
해싱 알고리즘을 일일이 열거하는 것은 이 책의 범위를 벗어나므로, 여기서는 가장 단순하면서도 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한 나눗셈 방식(Nodulo-Division Method) 하나만 살펴본다.

수식은 다음과 같이 정리할 수 있다.<br>

→ *h(x) = x mod m*

여기서 *h(x)* 는 입력값 *x*의 해시 함수를 통해 생성된 결과다.<br>
*m*은 해시 테이블의 크기로, 일반적으로 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다.<br>
* **참고 | 멱수**<br>
  거듭제곱으로 된 수
  
*h(x)* 는 이 값의 모듈로 연산의 결과로, 매우 단순한 방법이지만 실무에서는 이미 많은 키 세트가 충분히 랜덤한 상태고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로는 잘 동작한다.<br>
*x*는 어떤 간단한 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키의 값이다.<br>
"이펙티브 자바"의 저자 조슈아 블로크는 자바를 설계할 때, 값 *x*를 다음과 같이 다항식의 결과로 정의했다.
```
P(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]
```
여기서 *x*를 31로 하는 거듭제곱 P(31)의 연산으로 정의했다고 밝힌 바 있다.<br>
* x는 보통 문자열에 입력할 수 있는 문자의 개수와 비슷한 정도가 좋으며 보통 영어 소문자만 들어가는 경우 **x = 31**을 사용하고 대소문자 모두 들어가는 경우 **x = 53**을 사용한다.

조슈아 블로크는 여러 해시 함수의 성능을 조사했고 "The C Programming Language" 책에서 다음과 같이 P(31)을 찾아냈다.
```c
// C
/* hash: 문자열 s에 대한 해시 값 구성 */
usigned hash(char *s) {
    unsigned hashval;
    
    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
}
```
이 값은 1997년 당시 RISC(CPU 명령어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만든 과거 CPU의 한 형태로, 현재는 거의 모든 스마트폰에 답재되는 ARM CPU의 기본 구조로 다시 전성기를 맞이하고 있다) 머신에서 가장 저렴한 계산 비용이 들었다고 하며, 비슷한 성능을 지닌 P(33)과 고민 끝에 소수인 31을 매직 넘버(Magic Number)로 택했다고 한다.<br>
물론 더욱 복잡한 함수를 적용할 수도 있었겠지만 이 정도로 간단한 형태가 성능과 충돌의 적절한 합의점이었으며 실제로 31은 메르센 소수(Mersenne Prime)(2^5-1, 2의 거듭제곱에서 1이 모자란 수 중 소수로 매우 신비한 성질을 지닌다)로 수학적으로 나쁘지 않은 선택이기도 하다.

다음은 실제 자바 JDK에 포함된 해시 코드 중 일부다.
```java
// 자바(Java)
hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
```
이처럼 해시 함수는 매우 중요한 역할을 하는데, 몇 년 전 구글은 해시 함수를 딥러닝으로 학습한 모델을 적용해 충돌을 최소화하는 논문을 발표하며, 해시 테이블 자료구조의 미래를 기대케 하기도 했다.

> 그림 11-4

<br><br>

## 충돌
아무리 좋은 해시 함수라도 그림 11-5(285p)와 같이 충돌(Collision)은 발생하게 된다.

> 그림 11-5

이 그림에서 윤아와 서현은 해시 값이 2로 같은 값이 되어 충돌이 발생했다. 충돌이 발생하는 경로는 파란색으로 표시했다.
<br><br>

**하나의 버켓에 여러 개의 슬롯**을 두는 이유는 **서로 다른 두 개의 키가 해시 함수에 의해 동일한 해시 주소로 변환**될 수 있으므로 여러 개의 항목을 동일한 버켓에 저장하기 위함이다.

<img src="https://user-images.githubusercontent.com/55045377/116966827-fa34fa00-aceb-11eb-8ca0-d756a60b8d22.png">

서로 다른 두 개의 탐색 키 k1과 k2에 대하여 h(k1) = h(k2)인 경우를 충돌(collision)이라고 하며, 이러한 키 k1과 k2를 동의어(synonym)라 한다. 만약 충돌이 발생하면 같은 버켓에 있는 다른 슬롯에 항목을 저장하게 된다. 충돌이 자주 발생하면 버켓 내부에서의 순차 탐색 시간이 길어져서 탐색 성능이 저하될 수 있으므로 해시 함수를 수정하거나 해시 테이블의 크기를 적절히 조절해주어야 한다.


이제 이처럼 충돌이 발생할 경우 어떤 식으로 처리하게 되는지 살펴보자.
<br><br>

## 개별 체이닝
먼저, 입력값은 다음 표 11-1(286p)과 같이 정해보자. 해시는 키를 해싱한 결과며, '윤아'와 '서현'을 해싱한 결과는 충돌한다고 가정한다.

> 표 11-1

이 표를 개별 체이닝(Separate Chaining) 방식으로 구현하면 다음 그림 11-6(286p)과 같다.

> 그림 11-6

해시 테이블의 기본 방식이기도 한 개별 체이닝은 충돌 발생 시 이 그림과 같이 연결 리스트로 연결(link)하는 방식이다.<br>
충돌이 발생한 '윤아'와 '서현'은 '윤아'의 다음 이이템이 '서현'인 형태로 서로 연결 리스트로 연결되었다. <br>
이처럼 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로, 개별 체이닝 방식은 인기가 높다.<br>
원래 해시 테이블 구조의 원혀이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 바로 이 방식을 말한다.<br>
간단한 원리를 요약하면 다음과 같다.
```
1. 키의 해시 값을 계산한다.
2. 해시 값을 이용해 배열의 인덱스를 구한다.
3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
```
잘 구현한 경우 대부분의 탐색은 O(1)이지만 최악의 경우, 즉 모든 해시 충돌이 발생했다고 가정할 경우에는 O(n)이 된다.
<br><br>

## 오픈 어드레싱
오픈 어드레싱(Open Addressing) 방식은 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식이다.<br>
사실상 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다.<br>
충돌이 일어나면 테이블 공간 내에서 탐사(Probing)를 통해 빈 공간을 찾아 해결하며, 이 때문에 개별 체이닝 방식과 달리, 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.

> 그림 11-7

마찬가지로 표 11-1(286p)을 입력값으로 했을 때 오픈 어드레싱으로 표현하면 그림 11-7(287p)과 같다.<br>
여러 가지 오픈 어드레싱 방식 중에서 가장 간단한 방식은 선형 탐사(Linear Probing)방식은 충돌이 발생할 경우 해당 위치부터 순차적으로 탐사를 하나씩 진행한다.<br>
특정 위치가 선점되어 있으면 바로 그다음 위치를 확인하는 식이다.<br>
이렇게 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입하게 된다.<br>
가장 가까운 다음 빈 위치를 탐사해 새 키를 삽입한다.<br>
그림 11-7(287p)에서도 '윤아' 다음에 '서현'의 해시값이 동일한 2로 충돌이 발생했고, 다음번 빈 위치를 탐색하며 그다음 위치인 3에 '서현'이 들어가게 된다.<br>
이처럼 선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편이기도 하다.

선형 탐사의 한 가지 문제점은 해시 테이블에 저장되는 데이터들이 고르게 분포되지 않고 뭉치는 경향이 있다는 점이다.<br>
해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 이러한 현상을 클러스터링(Clustering)이라 하는데, 클러스터들이 점점 커지게 되면 인근 클러스터들과 서로 합쳐지는 일이 발생한다.<br>
그렇게 되면 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다.<br>
이러한 클러스터링 현상은 탐사 시간을 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어뜨리는 원인이 된다.

오픈 어드레싱 방식은 버킷 사이즈보다 큰 경우에는 삽입할 수 없다. <br>
따라서 일정 이상 채워지면, 즉 기준이 되는 로드 팩터 비율을 넘어서게 되면, 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 키기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 일어난다.<br>
이는 동적 배열에서 공간이 가득 찰 경우, 더블링으로 새롭게 복사해서 옮겨가는 과정과 유사하다.
<br><br>

## 언어별 해시 테이블 구현 방식
리스트와 함께 파이썬에서 가장 흔하게 쓰이는 자료형인 딕셔너리는 해시 테이블로 구현되어 있다.<br>
면접 시 "해시 테이블로 구현된 파이썬의 자료형을 제시하라."는 질문을 받는다면 주저 없이 딕셔너리라고 답할 수 있어야 한다.<br>
그렇다면 과연 파이썬의 해시 테이블은 충돌 시 어떤 방식을 사용할까?<br>
정답부터 말하자면 오픈 어드레싱 방식으로 구현되어 있다. <br>
CPython 구현에는 다음과 같은 주석이 적혀 있다.
> 체이닝 시 malloc으로 메모리를 할당하는 오버헤드가 높아 오픈 어드레싱을 택했다.

또한 "Beautiful Code" 책에서 앤드큐 커클링(Andrew Kuchling)도 18장, '파이썬의 사전 구현: 모든 이를 위한 범용 자료구조 만들기'에서 파이썬이 체이닝을 사용하지 않는 이유를 설명한 바 있는데, 연결 리스트를 만들기 위해서는 추가 메모리 할당이 필요하고, 추가 메모리 할당은 상대적으로 느린 작업이기 때문에 택하지 않았다고 기술했다.

파이썬의 해시 테이블이 개별 체이닝 방식이 아니란 점은 사실 면접관조차 잘 모를 수 있다.<br>
원래 해시 테이블은 해싱과 체이닝의 결합으로 탄생했고, 교과서에는 개별 체이닝 방식만 설명하는 경우가 일반적이기 때문이다.<br>
부록 A에서는 이처럼 면접관이 잘못 알고 있는 사실에 대한 대처 방안을 소개하므로 관심있는 분들은 참고하기 바란다.

그렇다면 왜 오픈 어드레싱일까? 다음 그래프가 그 이유를 잘 설명해준다.

> 그림 11-8

그림 11-8(289p)에서 오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이 더 좋다.<br>
그러나 슬롯의 80% 이상이 차게 되면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할수 없다.<br>
빈 공간을 탐사하는 선형 탐사 방식은 공간이 찰수록 탐사에 점점 더 오랜시간이 걸리며, 가득 차게 될 경우 더 이상 빈 공간을 찾을 수 없기 때문이다.<br>
따라서 최근의 루비나 파이썬같은 모던(Modern) 언어들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신, 로드 팩터를 작게 잡아 성능 저하 문제를 해결한다.<br>
파이썬의 로드 팩터는 0.66으로 자바보다 작으며 루비는 0.5로 훨씬 더 작다.<br>
둘은 모두 오픈 어드레싱 방식을 택하고 있다. <br>
각 언어별 해시 테이블의 구현 방식을 모두 정리하면 표 11-2(290p)와 같다.

> 표 11-2

<br><br>


























---

# 출처
* **해시** [[해시](#해시)]<br>
  https://velog.io/@zuyonze/%ED%95%B4%EC%8B%9C%ED%95%A8%EC%88%98%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0

* **해싱, 충돌** [[해싱](#해싱)] [[충돌](#충돌)]<br>
  https://mattlee.tistory.com/62 [waca's field]
