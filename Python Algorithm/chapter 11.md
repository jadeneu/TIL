# 목차


# 11장 해시 테이블
> 해시 테이블 또는 해시 맵은 키를 값에 매필할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료구조다.

해시 테이블의 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 점이다.<br>
덕분에 데어터 양에 관계 없이 빠른 성능을 기대할 수 있다는 장점이 있다.<br>
해시 테이블은 지금까지도 현대 컴퓨터 프로그래밍 언어에서 유용하게 사용되는 매우 중요한 자료구조다.
<br><br>

## 해시
> 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 말한다.

해시 테이블의 핵심은 해시 함수다. 여기서 입력값은 ABC, 1324BC, AF32B로 각각 3글자, 6글자, 5글자이지만, 화살표로 표시한 특정 함수를 통과하면 2바이트의 고정 크기 값으로 매핑된다.<br>
여기서 화살표 역할을 하는 함수가 바로 해시 함수다.
```
ABC    -> A1
1324BC -> CB
AF32B  -> D5
```
<br>

해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱(Hashing)이라 하며, 해싱은 정보를 가능한 한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나다.<br>
해싱은 최적의 검색이 필요한 분야에 사용되며, 심볼 테이블(일반적으로 해시 테이블로 구현된다) 등의 자료구조를 구현하기에도 적합하다.<br>
이외에도 해시 함수는 체크섬(Checksum), 손실 압축, 무작위화 함수(Randomization Function), 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.<br>
그러나 어느 정도는 개념이 겹치긴 하지만, 서로 용도와 요구사함이 다른 만큼 각각 다르게 설계되고 최적화된다.

성능 좋은 해시 함수들의 특징은 다음과 같다.
* 해시 함수 값 충돌의 최소화
* 쉽고 빠른 연산
* 해시 테이블 전체에 해시 값이 균일하게 분포
* 사용할 키의 모든 정보를 이용하여 해싱
* 해시 테이블 사용 효율이 높을 것
<br><br>

## 생일 문제
그렇다면 충돌은 얼마나 많이 발생할까?<br>
생각보다 충돌은 쉽게 일어난다. 흔한 예로 생일 문제(Birthday Problem)를 들 수 있다.

생일의 가짓수는 365개(윤년 제외)이므로, 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면 비둘기집 원리(Pigeonhole Principle)에 따라 366명 이상이 모여야 일어나는 일 같다.<br>
하지만 실제로는 다음 그림과 같이 23명만 모여도 50%를 넘고, 57명이 모이면 그때부터는 99%를 넘어선다.

그림 11-1(281p)의 결과는 우리의 일반적인 상식에 반하는 내용이라 믿기지 않을 수도 있겠다. 그렇다면 실험을 통해 직접 확인해보자.<br>
생일 문제는 수식으로 증명하려면 상당히 어려운 계산이 필요하다.<br>
하지만 파이썬을 활용하면 간단한 실험을 통해서 어렵지 않게 증명할 수 있다.<br>
이러한 컴퓨터 실험을 통한 증명 방법은 1976년 4색 정리(지도에서 인접한 나라끼리 서로 다은 색을 칠하려면 4가지 색이면 충분하다는 정리)가 첫 번째 증명으로 가장 유명하며, 당시만 해도 고작 1,936개의 모델을 계산하는 데도 2대의 컴퓨터로 50일이 넘게 걸려 증명한 바 있다.

> 그림 11-1

물론, 지금은 훨씬 더 강력한 컴퓨터를 이용해 확률을 쉽게 계산해낼 수 있다.<br>
이러한 기법들은 '해커를 위한 통계학(Statistics for Hackers)'이라 일컬으며 상당한 호응을 얻기도 했다.<br>
그렇다면 정말로 23명만 있으면 생일이 같을 확률이 50%를 넘어설 수 있을까?

다음과 같이 계산 코드를 작성해서 직접 실험해보자.
```python
import random

TRIALS = 100000 # 10만 번 실험
same_birthdays = 0 # 생일이 같은 실험의 수

# 10만 번 실험 진행
for _ in range(TRIALS):
    birthdays = []
    # 23명이 모였을 때, 생일이 같을 경우 same_birthdays += 1
    for i in range(23):
        birthday = random.randint(1, 365)
        if birthday in birthdays:
            same_birthdays += 1
            break
        birthdays.append(birthday)
        
# 전체 10만 번 실험 중 생일이 같은 실험의 확률
print(f'{same_birthdays / TRIALS * 100}%')
-------
50.708%
```
여기서는 23명이 모이는 경우를 각각 10만 번 실험했다. 그 결과, 생일이 같을 확률은 약 50.7%가 나왔다.<br>
정말로 23명만 모여도 생일이 같을 확률이 50%를 넘어선다. 실험을 통해 직접 확인할 수 있었다.

이처럼 일반적인 상식(잘못된 상식)과는 달리, 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요하다.
<br><br>

## 비둘기집 원리
> 비둘기집 원리란, n개 아이템을 m개 컨테이너에 넣을 때, n>m이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리를 말한다.

왜 충돌은 일어날 수밖에 없을까? 비둘기집 원리는 충돌의 원리를 잘 설명한다. <br>
비둘기집 원리는 1834년 독일의 수학자 페터 디리클레(Peter Dirichlet)가  만든 것으로 '서랍 원리'라고도 불린다.<br>
간단한 귀류법으로 모순을 이끌어내 쉽게 증명할 수 있으며, 그림 11-2(282p)의 비둘기집 사진으로도 쉽게 이해된다.

> 그림 11-2

비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다.<br>
좋은 해시 함수라면 충돌을 최소화하여 단 1번의 충돌만 일어나게 하겠지만, 좋지 않은 해시 함수의 경우 심하면 9번을 모두 충돌해서, 9개의 공간 중 1개밖에 사용하지 못할 수도 있다.<br>
여러 번 충돌한다는 것은 그만틈 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.
<br><br>

## 로드 팩터
> 로드 팩터(Load Factor)란 해시 테이블에 저장된 데이터 개수 n을 버킷의 개수 k로 나눈 것이다.

→ *load factor = n/k*

로드 팩터 비율에 따라서 해시 함수를 재작성해야 될지 또는 해시 테이블의 크기를 조정해야 할지를 결정한다.<br>
또한 이 값은 해시 함수가 키들을 잘 분산해 주는지를 말하는 효율성 측정에도 사용된다.

자바 10에서는 해시맵의 디폴트 로드 팩터를 0.75로 정했으며 '시간과 공간 비용의 적절한 절충안'이라고 얘기한다.<br>
일반적으로 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하게 되며, 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당한다.
<br><br>

## 해시 함수
그림 11-3(283p)은 해시 함수를 통해 키가 해시 값으로 변경되는 과정을 도식화한 것이다.

> 그림 11-3

이처럼 해시 테이블을 인덱싱하기 위해 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다.<br>
해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다.<br>
해싱 알고리즘을 일일이 열거하는 것은 이 책의 범위를 벗어나므로, 여기서는 가장 단순하면서도 널리 쓰이는 정수형 해싱 기법인 모듈로 연산을 이용한 나눗셈 방식(Nodulo-Division Method) 하나만 살펴본다.

수식은 다음과 같이 정리할 수 있다.<br>

→ *h(x) = x mod m*

여기서 *h(x)* 는 입력값 *x*의 해시 함수를 통해 생성된 결과다.<br>
*m*은 해시 테이블의 크기로, 일반적으로 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다.<br>
*h(x)* 는 이 값의 모듈로 연산의 결과로, 매우 단순한 방법이지만 실무에서는 이미 많은 키 세트가 충분히 랜덤한 상태고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로는 잘 동작한다.<br>
*x*는 어떤 간단한 규칙을 통해 만들어낸 충분히 랜덤한 상태의 키의 값이다.<br>
"이펙티브 자바"의 저자 조슈아 블로크는 자바를 설계할 때, 값 *x*를 다음과 같이 다항식의 결과로 정의했다.
```
P(x) = s[0] * x^(n-1) + s[1] * x^(n-2) + ... + s[n-1]
```
여기서 *x*는 31로 하는 거듭제곱 P(31)의 연산으로 정의했다고 밝힌 바 있다.<br>
조슈아 블로크는 여러 해시 함수의 성능을 조사했고 "The C Programming Language" 책에서 다음과 같이 P(31)을 찾아냈다.
```c
// C
/* hash: 문자열 s에 대한 해시 값 구성 */
usigned hash(char *s) {
    unsigned hashval;
    
    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
}
```
이 값은 1997년 당시 RISC(CPU 명령어의 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만든 과거 CPU의 한 형태로, 현재는 거의 모든 스마트폰에 답재되는 ARM CPU의 기본 구조로 다시 전성기를 맞이하고 있다) 머신에서 가장 저렴한 계산 비용이 들었다고 하며, 비슷한 성능을 지닌 P(33)과 고민 끝에 소수인 31을 매직 넘버(Magic Number)로 택했다고 한다.<br>
물론 더욱 복잡한 함수를 적용할 수도 있었겠지만 이 정도로 간단한 형태가 성능과 충돌의 적절한 합의점이었으며 실제로 31은 메르센 소수(Mersenne Prime)(2^5-1, 2의 거듭제곱에서 1이 모자란 수 중 소수로 매우 신비한 성질을 지닌다)로 수학적으로 나쁘지 않은 선택이기도 하다.

다음은 실제 자바 JDK에 포함된 해시 코드 중 일부다.
```java
// 자바(Java)
hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());
```
이처럼 해시 함수는 매우 중요한 역할을 하는데, 몇 년 전 구글은 해시 함수를 딥러닝으로 학습한 모델을 적용해 충돌을 최소화하는 논문을 발표하며, 해시 테이블 자료구조의 미래를 기대케 하기도 했다.

> 그림 11-4

<br><br>

## 충돌
 























