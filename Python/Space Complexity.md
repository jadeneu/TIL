# 목차
* [공간 복잡도(space complexity)](#공간-복잡도space-complexity)
    + [정의 및 설명](#정의-및-설명)
    + [예시](#예시)
        - [공간 복잡도의 계산 1](#공간-복잡도의-계산-1)
        - [공간 복잡도의 계산 2](#공간-복잡도의-계산-2)
        - [공간 복잡도의 계산 3](#공간-복잡도의-계산-3)
        - [공간 복잡도의 계산 4](#공간-복잡도의-계산-4)
        - [공간 복잡도의 계산 5](#공간-복잡도의-계산-5)
* [출처](#출처)
<br><br><br>


# 공간 복잡도(space complexity)
## 정의 및 설명
* 공간 복잡도는 알고리즘을 수행시키기 위해 필요한 기억장치(memory)의 크기를 의미한다.

* 총 공간 요구 = 고정 공간 요구 + 가변 공간 요구로 나타낼 수 있으며 수식으로는 **S(P) = c + Sp(n)** 으로 표기한다.

    여기서 **고정 공간**은 입력의 출력의 횟수나 크기와 관계없는 공간의 요구(코드 저장 공간, 단순 변수, 고정 크기의 구조 변수, 상수)를 말한다.

    **가변 공간**은 해결하려는 문제의 특정 인스턴스에 의존하는 크기를 가진 구조화 변수들을 위해서 필요로 하는 공간, 함수가 순환 호출을 할 경우 요구되는 추가 공간, 그러니까 동적으로 필요한 공간을 말한다.
<br><br>

주어진 알고리즘을 실행시키기 위해 필요한 기억장치(space)는 다음과 같이 두 가지로 분류해 볼 수 있다.

**1. 알고리즘과 무관한 부분**<br>
: 알고리즘의 특성과는 무관한 부분으로 프로그램 코드를 저장하기 위한 공간, 프로그램을 수행하기 위해 시스템이 필요로 하는 공간 등이 이에 포함된다.<br>
**2. 알고리즘과 밀접한 부분**<br>
: 알고리즘의 특성과 밀접한 관계가 있는 부분으로서 문제를 해결하기 위해 필요로 하는 공간을 의미한다. 즉, 변수를 저장하기 위한 공간이나 순환 프로그램일 경우 순환 스택(recursion stack) 등이 이에 포함된다.

일반적으로 알고리즘의 공간 복잡도를 분석할때는 위의 두가지중 두 번째의 것을 계산하게 된다.<br>
즉, 알고리즘이 문제를 해결하기 위해서 **반드시 필요한 부분만을 계산**함으로써 주어진 알고리즘의 공간 복잡도를 계산한다.
<br><br>

## 예시
### 공간 복잡도의 계산 1
```java
int factorial(int n)
{
    if(n > 1) return n * factorial(n - 1);
    else return 1;
}
```
**공간 복잡도 = O(n)**<br>
n이 1 이하일 때까지 함수가 재귀적으로 호출되므로 스택에는 n부터 1까지 모두 쌓이게 될 것이다. 즉 공간 복잡도는 O(n)이 된다.
<br><br>

### 공간 복잡도의 계산 2
```java
int factorial(int n)
{
    int i = 0;
    int fac = 1;
    for(i = 1; i <= n; i++)
    {
        fac = fac * i;
    }
    return fac;
}
```
**공간 복잡도 = O(1)**<br>
n의 값에 상관없이 스택에는 n과 i 그리고 fac 변수만 저장된다. 여기서의 공간 복잡도는 O(1)이다.
<br><br>

### 공간 복잡도의 계산 3
```java
float abc(float a, float b, float c)
{
  return(a + b + b*c + (a + b - c)/(a + b) + 4.0);
}
```
**공간 복잡도 = 0**<br>
위의 프로그램에서 공간복잡도를 구하기 위해서 살펴볼 것은 변수 a, b, c 이다<br>
따라서, float형의 변수가 한 워드(word)를 차지한다고 가정하면, 공간복잡도는 '3워드'라고 생각할 수 있다. 그러나 변수 a, b, c 는 전달되는 인자(parameter)로서 함수 abc내에서 해결하고자 하는 문제와는 무관하다고 볼 수 있으므로 공간 복잡도는 0이다.
<br><br>

### 공간 복잡도의 계산 4
```java
float Sum(float a[], int n)
{
  float s = 0.0;
  for(int i = 1; i < = n; i++)
      s += a[i];
  return s;
}
```
**공간 복잡도 = n + 3**<br>
위의 프로그램에서 사용되는 변수는 a[], n, s, i 이다. 변수 a[]는 합을 구하기 위하여 반복문 내에서 n개의 원소가 모두 참조되고 있음을 볼 수 있다. 또한, n은 for-문을 벗어나기 위한 한계값으로 사용된다. 따라서 a[]와 n은 알고리즘이 해결하고자 하는 문제와 밀접한 관련이 있다고 볼 수 있다.<br>
그러므로 프로그램의 복잡도는 (a[]를 저장하기 위한 공간) + (변수 n, s, I를 위한 공간) = n + 3 이 된다.
<br><br>

### 공간 복잡도의 계산 5
```java
float RSum(float a[], int n)
{
  if(n <= 0)
    return (0.0);
  else
    return (RSum(a, n-1) + a[n]);
}
```
**공간 복잡도 = 3(n + 1)**<br>
위의 프로그램은 순환기법(recursion)으로 작성된 것이다. 위의 경우 살펴볼 변수는 a[], n이다.<br>
우선 변수 n은 if-문 내에서 순환의 한계값으로 사용되고 있음을 볼 수 있다. 또한, 변수 a[]는 합을 구하기 위하여 사용되고 있으며 a[]의 원소 중에서 n번째의 원소만 필요로 한다.<br>
따라서 변수 a[]와 n이 모두 알고리즘과 밀접한 관계가 있으므로, 프로그램이 필요로 하는 공간은 (a[]의 n번째 원소를 의한 공간) + (n을 위한 공간) = 1 + 1 으로 볼 수 있다.<br>
그러나 위의 프로그램은 순환기법에 의해 작성되었음을 고려해야 한다. 즉, 프로그램이 순환적으로 실행될 것을 고려해서 몇번의 순환후에 실행이 종료되는지(the depth of recursion)를 계산해야 하며, 또한 순환을 위해서 필요한 복귀 주소(return address)를 저장할 공간도 계산해야 한다.<br>
그러므로 프로그램의 공간 복잡도는 (depth of recursion)×(a[n], n, 복귀 주소를 위한 공간) = (n+1)×3 이 된다.
<br><br>

### 나의 결론
**공간 복잡도를 계산할 때는 스택에 얼마나 쌓일지를 생각하자!**




















---
# 출처
* https://qwe1qwe.tistory.com/880 [Roopretelcham]
* https://madplay.github.io/post/time-complexity-space-complexity
