# 목차
* [타입추론(type inference)](#타입추론type-inference)
* [함수(function)](#함수function)
  + [단일 표현식 함수](#단일-표현식-함수)
* [출처](#출처)
---
* Kotlin 웹 컴파일러 사이트<br>
  https://play.kotlinlang.org
---
# 타입추론(type inference)
타입추론은 변수나 함수들을 선언할 때나 연산이 이루어질 때 자료형을 코드에 명시하지 않아도 코틀린이 **자동으로 자료형을 추론해주는 기능**이다.

```kotlin
val stringValue = "문자열을 할당해 볼까요?"  // String 자료형 생략
val stringValue: String = "문자열을 할당해 볼까요?"  // String 자료형 명시

var intArr = arrayOf(1,2,3,4,5)  // Array<Int> 자료형 생략
var intArr: Array<Int> = arrayOf(1,2,3,4,5)  // Array<Int> 자료형 명시
```
이는 변수가 선언될 때 할당된 **값의 형태**로 해당 변수가 어떤 자료형을 가지는지 **추론**이 가능하기 때문에 생략할 수 있다.

사실 기본 자료형들도 선언시 값을 할당만 해준다면 대부분 자료형을 명시할 필요가 없다.<br>
자료형 없이 값을 할당한다면 어떤 자료형으로 지정될까?

* **일반 정수형 리터럴을 할당하면** Int
  ```kotlin
  var a = 1234  // a는 Int형 변수로 지정
  ```
  
* **L이 붙은 정수형 리터럴은** Long
  ```kotlin
  var b = 1234L  // b는 Long형 변수로 지정
  ```
  
* **일반 실수형 리터럴은** Double
  ```kotlin
  var c = 12.45  // c는 Double형 변수로 지정
  ```
  
* **f가 붙은 실수형 리터럴은** Float 형으로 추론된다.
  ```kotlin
  var d = 12.45f  // d는 Float형 변수로 지정
  ```
  
* **16진수와 2진수는** Int 형으로 추론된다.
  ```kotlin
  var e = 0xABCD
  var f = 0b0101010
  ```
  
* **Boolean과 Char** 역시 자료형 없이도 추론이 가능하다.
  ```kotlin
  var g = true
  var h = 'c'
  ```
<br>

→ 반드시 **특정한 자료형**으로 지정해야하는 상황이 아니라면 대부분은 코틀린의 타입추론 기능을 이용하여 코드량을 줄일 수 있다.
<br><br><br>

# 함수(function)
함수는 특정한 동작을 하거나 원하는 결과값을 연산하는데 사용한다.

우리가 코드를 짜고 있는 **main()** 이나<br>
코드 내에서 사용하는 **println("")** 같은 것도 모두 함수이다.

그렇다면 간단하게 **3개의 Int 정수를 더하는 함수**를 만들어 보자.<br>
코틀린에서 함수는 어디에나 둘 수 있지만 지금은 **main 함수 바깥**에 함수를 만들어 보자.<br>
1. 변수가 var이나 val로 시작하듯 함수도 function의 준말인 **fun**으로 시작한다.<br>
2. 값을 더하는 함수이니 이름은 **add**로 해보자.<br>
3. 그리고 괄호를 만들어 함수가 받아야 할 **Int 정수값 a,b,c**를 써준다.
4. 다음 괄호를 닫고 a,b,c를 더해서 **반환하는 값의 자료형**을 써준다. 이를 **반환형**이라고 한다. 반환값이 없다면 생략해도 무방하다.
5. 다음은 함수의 내용을 만들기 위해 **중괄호**를 사용해보자. 중괄호 안에 **함수가 해야할 구문**을 적을텐데, 여기서는 단순히 **a,b,c를 더한 값을 반환**하는 목적이므로 **return a+b+c** 라고 기술해 준다.<br>
 함수 안에서 return은 뒤에 오는 값을 반환하는 키워드로 return이 발생한다면 함수의 중간이더라도 값을 반환하고 함수를 종료하게 된다.
<br><br>

```kotlin
fun main() {
    println(add(5, 6, 7))
}

fun add(a: Int, b: Int, c: Int): Int {
    return a + b + c
}
---------------------------------------
18  // 실행결과
```
<br>

그런데 이 함수는 여러 가지 일을 하는 것이 아닌 a,b,c를 단순히 더해서 반환하는 역할만 한다.<br>
이럴 때는 함수를 좀 더 간단하게 기술할 수 있도록 **단일 표현식 함수(single-expression function)** 라는 것을 지원한다.
<br><br>

## 단일 표현식 함수
위에서 만든 함수와 같은 기능의 함수를 마치 변수에 결과값을 할당하듯 **식을 할당하여** 만들 수 있다.
```kotlin
fun main() {
    println(add(5, 6, 7))
}

fun add(a: Int, b: Int, c: Int) = a + b + c
```
또한 단일 표현식 함수에서는 **반환형의 타입추론**이 가능하므로 **반환형을 생략**할 수 있다.

코틀린에서 함수는 내부적으로 기능을 가진 형태이지만 외부에서 볼 때는 파라미터를 넣는다는 점 외에는 **자료형이 결정된 변수**라는 개념으로 접근하는 것이 좋다!<br>
그래야 나중에 배울 **함수형 언어**라는 코틀린의 중요한 특징을 이해하기 쉽다.
<br><br><br>


















---
# 출처
* 테크과학! DiMo
  https://www.youtube.com/channel/UCVqKQvma-Cr-eQ4hgxETAFQ
  
<br><br>
